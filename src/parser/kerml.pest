// KerML Grammar - Kernel Modeling Language (base for SysML v2)
// This will be incrementally expanded following TDD

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ line_comment }

line_comment = { "//" ~ (!"\n" ~ ANY)* }
block_comment = @{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

// Tokens
subclassifier_token = @{ "subclassifier" ~ !(ASCII_ALPHANUMERIC | "_") }
specialization_token = @{ "specialization" ~ !(ASCII_ALPHANUMERIC | "_") }
redefinition_token = @{ "redefinition" ~ !(ASCII_ALPHANUMERIC | "_") }
multiplicity_token = @{ "multiplicity" ~ !(ASCII_ALPHANUMERIC | "_") }
interaction_token = @{ "interaction" ~ !(ASCII_ALPHANUMERIC | "_") }
differences_token = @{ "differences" ~ !(ASCII_ALPHANUMERIC | "_") }
conjugation_token = @{ "conjugation" ~ !(ASCII_ALPHANUMERIC | "_") }
conjugates_token = @{ "conjugates" ~ !(ASCII_ALPHANUMERIC | "_") }
classifier_token = @{ "classifier" ~ !(ASCII_ALPHANUMERIC | "_") }
dependency_token = @{ "dependency" ~ !(ASCII_ALPHANUMERIC | "_") }
disjoining_token = @{ "disjoining" ~ !(ASCII_ALPHANUMERIC | "_") }
intersects_token = @{ "intersects" ~ !(ASCII_ALPHANUMERIC | "_") }
inverting_token = @{ "inverting" ~ !(ASCII_ALPHANUMERIC | "_") }
namespace_token = @{ "namespace" ~ !(ASCII_ALPHANUMERIC | "_") }
nonunique_token = @{ "nonunique" ~ !(ASCII_ALPHANUMERIC | "_") }
specializes_token = @{ "specializes" ~ !(ASCII_ALPHANUMERIC | "_") }
succession_token = @{ "succession" ~ !(ASCII_ALPHANUMERIC | "_") }
predicate_token = @{ "predicate" ~ !(ASCII_ALPHANUMERIC | "_") }
protected_token = @{ "protected" ~ !(ASCII_ALPHANUMERIC | "_") }
references_token = @{ "references" ~ !(ASCII_ALPHANUMERIC | "_") }
redefines_token = @{ "redefines" ~ !(ASCII_ALPHANUMERIC | "_") }
standard_token = @{ "standard" ~ !(ASCII_ALPHANUMERIC | "_") }
featuring_token = @{ "featuring" ~ !(ASCII_ALPHANUMERIC | "_") }
metaclass_token = @{ "metaclass" ~ !(ASCII_ALPHANUMERIC | "_") }
connector_token = @{ "connector" ~ !(ASCII_ALPHANUMERIC | "_") }
datatype_token = @{ "datatype" ~ !(ASCII_ALPHANUMERIC | "_") }
disjoint_token = @{ "disjoint" ~ !(ASCII_ALPHANUMERIC | "_") }
featured_token = @{ "featured" ~ !(ASCII_ALPHANUMERIC | "_") }
function_token = @{ "function" ~ !(ASCII_ALPHANUMERIC | "_") }
language_token = @{ "language" ~ !(ASCII_ALPHANUMERIC | "_") }
metadata_token = @{ "metadata" ~ !(ASCII_ALPHANUMERIC | "_") }
const_token = @{ "const" ~ !(ASCII_ALPHANUMERIC | "_") }
behavior_token = @{ "behavior" ~ !(ASCII_ALPHANUMERIC | "_") }
binding_token = @{ "binding" ~ !(ASCII_ALPHANUMERIC | "_") }
comment_token = @{ "comment" ~ !(ASCII_ALPHANUMERIC | "_") }
crosses_token = @{ "crosses" ~ !(ASCII_ALPHANUMERIC | "_") }
default_token = @{ "default" ~ !(ASCII_ALPHANUMERIC | "_") }
derived_token = @{ "derived" ~ !(ASCII_ALPHANUMERIC | "_") }
feature_token = @{ "feature" ~ !(ASCII_ALPHANUMERIC | "_") }
hastype_token = @{ "hastype" ~ !(ASCII_ALPHANUMERIC | "_") }
implies_token = @{ "implies" ~ !(ASCII_ALPHANUMERIC | "_") }
inverse_token = @{ "inverse" ~ !(ASCII_ALPHANUMERIC | "_") }
istype_token = @{ "istype" ~ !(ASCII_ALPHANUMERIC | "_") }
library_token = @{ "library" ~ !(ASCII_ALPHANUMERIC | "_") }
ordered_token = @{ "ordered" ~ !(ASCII_ALPHANUMERIC | "_") }
package_token = @{ "package" ~ !(ASCII_ALPHANUMERIC | "_") }
portion_token = @{ "portion" ~ !(ASCII_ALPHANUMERIC | "_") }
private_token = @{ "private" ~ !(ASCII_ALPHANUMERIC | "_") }
public_token = @{ "public" ~ !(ASCII_ALPHANUMERIC | "_") }
struct_token = @{ "struct" ~ !(ASCII_ALPHANUMERIC | "_") }
subsets_token = @{ "subsets" ~ !(ASCII_ALPHANUMERIC | "_") }
subtype_token = @{ "subtype" ~ !(ASCII_ALPHANUMERIC | "_") }
typing_token = @{ "typing" ~ !(ASCII_ALPHANUMERIC | "_") }
variation_token = @{ "variation" ~ !(ASCII_ALPHANUMERIC | "_") }
abstract_token = @{ "abstract" ~ !(ASCII_ALPHANUMERIC | "_") }
about_token = @{ "about" ~ !(ASCII_ALPHANUMERIC | "_") }
alias_token = @{ "alias" ~ !(ASCII_ALPHANUMERIC | "_") }
assoc_token = @{ "assoc" ~ !(ASCII_ALPHANUMERIC | "_") }
chains_token = @{ "chains" ~ !(ASCII_ALPHANUMERIC | "_") }
class_token = @{ "class" ~ !(ASCII_ALPHANUMERIC | "_") }
composite_token = @{ "composite" ~ !(ASCII_ALPHANUMERIC | "_") }
conjugate_token = @{ "conjugate" ~ !(ASCII_ALPHANUMERIC | "_") }
differs_token = @{ "differs" ~ !(ASCII_ALPHANUMERIC | "_") }
expr_token = @{ "expr" ~ !(ASCII_ALPHANUMERIC | "_") }
false_token = @{ "false" ~ !(ASCII_ALPHANUMERIC | "_") }
filter_token = @{ "filter" ~ !(ASCII_ALPHANUMERIC | "_") }
first_token = @{ "first" ~ !(ASCII_ALPHANUMERIC | "_") }
import_token = @{ "import" ~ !(ASCII_ALPHANUMERIC | "_") }
inout_token = @{ "inout" ~ !(ASCII_ALPHANUMERIC | "_") }
locale_token = @{ "locale" ~ !(ASCII_ALPHANUMERIC | "_") }
member_token = @{ "member" ~ !(ASCII_ALPHANUMERIC | "_") }
return_token = @{ "return" ~ !(ASCII_ALPHANUMERIC | "_") }
subset_token = @{ "subset" ~ !(ASCII_ALPHANUMERIC | "_") }
unions_token = @{ "unions" ~ !(ASCII_ALPHANUMERIC | "_") }
typed_token = @{ "typed" ~ !(ASCII_ALPHANUMERIC | "_") }
bool_token = @{ "bool" ~ !(ASCII_ALPHANUMERIC | "_") }
else_token = @{ "else" ~ !(ASCII_ALPHANUMERIC | "_") }
flow_token = @{ "flow" ~ !(ASCII_ALPHANUMERIC | "_") }
from_token = @{ "from" ~ !(ASCII_ALPHANUMERIC | "_") }
meta_token = @{ "meta" ~ !(ASCII_ALPHANUMERIC | "_") }
new_token = @{ "new" ~ !(ASCII_ALPHANUMERIC | "_") }
null_token = @{ "null" ~ !(ASCII_ALPHANUMERIC | "_") }
step_token = @{ "step" ~ !(ASCII_ALPHANUMERIC | "_") }
then_token = @{ "then" ~ !(ASCII_ALPHANUMERIC | "_") }
true_token = @{ "true" ~ !(ASCII_ALPHANUMERIC | "_") }
type_token = @{ "type" ~ !(ASCII_ALPHANUMERIC | "_") }
and_token = @{ "and" ~ !(ASCII_ALPHANUMERIC | "_") }
doc_token = @{ "doc" ~ !(ASCII_ALPHANUMERIC | "_") }
end_token = @{ "end" ~ !(ASCII_ALPHANUMERIC | "_") }
for_token = @{ "for" ~ !(ASCII_ALPHANUMERIC | "_") }
inv_token = @{ "inv" ~ !(ASCII_ALPHANUMERIC | "_") }
var_token = @{ "var" ~ !(ASCII_ALPHANUMERIC | "_") }
not_token = @{ "not" ~ !(ASCII_ALPHANUMERIC | "_") }
out_token = @{ "out" ~ !(ASCII_ALPHANUMERIC | "_") }
rep_token = @{ "rep" ~ !(ASCII_ALPHANUMERIC | "_") }
xor_token = @{ "xor" ~ !(ASCII_ALPHANUMERIC | "_") }
all_token = @{ "all" ~ !(ASCII_ALPHANUMERIC | "_") }
as_token = @{ "as" ~ !(ASCII_ALPHANUMERIC | "_") }
by_token = @{ "by" ~ !(ASCII_ALPHANUMERIC | "_") }
if_token = @{ "if" ~ !(ASCII_ALPHANUMERIC | "_") }
in_token = @{ "in" ~ !(ASCII_ALPHANUMERIC | "_") }
of_token = @{ "of" ~ !(ASCII_ALPHANUMERIC | "_") }
or_token = @{ "or" ~ !(ASCII_ALPHANUMERIC | "_") }
to_token = @{ "to" ~ !(ASCII_ALPHANUMERIC | "_") }

// Delimiters and Operators
forward_curl_brace = @{ "{" }
backward_curl_brace = @{ "}" }
semi_colon = @{ ";" }
double_colon = @{ "::" }
colon = @{ ":" }
wildcard = @{ "*" }
space = @{ " " }
question_mark = @{ "?" }
double_question_mark = @{ "??" }
conjugate_operator = @{ "~" }
conjugation_operator = { "~" }
at_symbol = @{ "@" }

// Keywords - ordered by length (longest first) to avoid prefix matching issues
keyword = @{
    subclassifier_token | specialization_token | redefinition_token | multiplicity_token | interaction_token
    | differences_token | conjugation_token | conjugates_token | classifier_token | dependency_token
    | disjoining_token | intersects_token | inverting_token | namespace_token | nonunique_token
    | specializes_token | succession_token | predicate_token | protected_token | references_token
    | redefines_token | standard_token | featuring_token | metaclass_token | connector_token
    | datatype_token | disjoint_token | featured_token | function_token | language_token
    | metadata_token | const_token | behavior_token | binding_token | comment_token
    | crosses_token | default_token | derived_token | feature_token | hastype_token
    | implies_token | inverse_token | istype_token | library_token | ordered_token
    | package_token | portion_token | private_token | public_token | struct_token
    | subsets_token | subtype_token | typing_token | abstract_token | about_token
    | alias_token | assoc_token | chains_token | class_token | composite_token
    | conjugate_token | differs_token | expr_token | false_token | filter_token
    | first_token | import_token | inout_token | locale_token | member_token
    | return_token | subset_token | unions_token | typed_token | bool_token
    | else_token | flow_token | from_token | meta_token | null_token | step_token
    | then_token | true_token | type_token | and_token | doc_token | end_token
    | for_token | inv_token | var_token | not_token | out_token | rep_token | xor_token
    | all_token | as_token | by_token | if_token | in_token | of_token | or_token | to_token
    | variation_token
}

// Terminals

decimal = @{ ASCII_DIGIT+ }
fraction = @{ "." ~ decimal }
float = @{ decimal ~ fraction? | fraction }
exponent = @{ ^"e" ~ ("+" | "-")? ~ decimal }
number = @{ float ~ exponent? }

unrestricted_name = @{ "'" ~ (("\\" ~ ("'" | "\"" | "b" | "f" | "t" | "n" | "r" | "\\")) | (!"'" ~ !"\\" ~ ANY))* ~ "'" }
name = @{ identifier | unrestricted_name }

// Identifiers
identifier = @{ !keyword ~ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }

// Name that can be a keyword (used for type identifiers)
name_identifier = @{ 
    unrestricted_name 
    | ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")*
}

// Identification fragments
short_name = { "<" ~ name ~ ">" }
regular_name = { name }
identification = { (short_name ~ regular_name?) | regular_name }

// Relationship Operators (alternative syntax)
specializes_operator = @{ ":>" | specializes_token }
subsets_operator = @{ ":>" | subsets_token }
references_operator = @{ "::>" | references_token }
crosses_operator = @{ "=>" | crosses_token }
redefines_operator = @{ ":>>" | redefines_token }
typed_by_operator = @{ ":" | (typed_token ~ " " ~ by_token) }
conjugates_operator = @{ "~" | conjugates_token }

// Enum Types
visibility_kind = @{ protected_token | private_token | public_token }
// Use negative lookahead to ensure direction kinds are complete words
// This prevents "in" from matching the start of "interface"
feature_direction_kind = @{ inout_token | in_token | out_token }

// Expression operators (used by kerml_expressions.pest)
unary_operator = @{ "+" | "-" ~ !(">" | "->") | not_token | "~" }
classification_test_operator = @{ "@@" | hastype_token | istype_token | "@" }
equality_operator = @{ "!==" | "!=" | "===" | "==" }
relational_operator = @{ "<=" | "<" | ">=" | ">" }
additive_operator = { "+" | "-" }
multiplicative_operator = { "*" | "/" | "%" }
exponentiation_operator = { "**" | "^" }

import_kind = @{ "::*::**" | "::**" | "::*" }

// Common Fragments

abstract_marker = { abstract_token }
visibility = { visibility_kind }
const_modifier = { const_token }
derived = { derived_token }
end_marker = { end_token }
variable_marker = { variation_token | var_token }
feature_modifier = { const_modifier | derived | end_marker | variable_marker }
sufficient = { all_token }
standard_marker = { standard_token }
import_all = { all_token }

// Common modifier pattern for abstract/composite/portion
acp_modifier = { abstract_token | composite_token | portion_token }

// Unified: Feature prefix modifiers (abstract, composite, portion, member, const, etc.)
feature_prefix_modifiers = { (abstract_token | composite_token | portion_token | member_token | const_modifier | derived | end_marker | variable_marker)* }

// Unified: Classifier relationships (includes inheritance for classifiers)
classifier_relationships = { (any_relationship | inheritance)* }

// Unified: Ordering modifiers for multiplicities
ordering_modifiers = { (ordered_token | nonunique_token)* }

// Unified: Connector-like feature modifiers (acp_modifier? ~ feature_modifier?)
connector_feature_modifiers = { acp_modifier? ~ feature_modifier? }

// Unified: Connector body suffix (memberships and body)
connector_body_suffix = { membership? ~ owning_membership? ~ end_feature_membership* ~ namespace_body }

// Unified: Specialization prefix for standalone relationship rules
specialization_prefix = { (specialization_token ~ identification?)? }

// Unified: Optional specialization part (relationships and/or multiplicity, all optional)
optional_specialization_part = { specialization_part_content? }

// Unified: Required specialization part content (at least one relationship or multiplicity)
specialization_part_content = {
    any_relationship+ ~ multiplicity_part? ~ any_relationship*
    | multiplicity_part ~ any_relationship*
}

// Unified: Type body (namespace body or semicolon terminator)
type_body = { namespace_body | ";" }

// Unified: Feature declaration (optional identification with optional specialization)
feature_declaration = { identification? ~ feature_specialization_part? }

multiplicity_properties = {
    (ordered_token ~ nonunique_token?)
    | (nonunique_token ~ ordered_token?)
}

enum_type = {
    visibility_kind
    | feature_direction_kind
    | unary_operator
    | classification_test_operator
    | equality_operator
    | import_kind
    | relational_operator
}

// Union Types

// InlineExpression - union of expression types that can appear inline
inline_expression = {
    operator_expression  // Top-level expression that includes all operators and sub-expressions
}

// NonOwnerType - union of non-owning relationship types
// Note: annotation must come before membership since membership has all optional fields
non_owner_type = {
    annotation
    | membership
}

// Annotations

// Helper for string literals
string_value = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }

// Helper for character literals
char_value = @{ "'" ~ (!"'" ~ ANY) ~ "'" }

// Annotation - references another element
annotation = {
    element_reference
}

// Comment per official grammar:
// Comment = ( 'comment' Identification? ('about' Annotation (',' Annotation)*)? )?
//           ( 'locale' STRING_VALUE )?
//           REGULAR_COMMENT
comment_annotation = { 
    (comment_token ~ identification? ~ (about_token ~ element_reference ~ ("," ~ element_reference)*)?)? ~
    (locale_token ~ string_value)? ~ 
    block_comment
}

documentation = { 
    doc_token ~ identification? ~ (locale_token ~ string_value)? ~ (block_comment | ";")? }


// Textual representation with language
textual_representation = {
    (rep_token ~ identification?)? ~ language_token ~ string_value ~ block_comment? ~ ";"?
}

// Owned Annotations

owned_annotation = {
    annotating_element
}

annotating_element = {
    comment_annotation
    | documentation
    | textual_representation
    | metadata_feature
    | ignored_block_comment
}

ignored_block_comment = _{ block_comment }

// User-Defined Keyword
// A user-defined keyword is a (possibly qualified) metaclass name or short name preceded by #
// Examples: #atom, #command, #SecurityRelated, #MyPackage::MyMetaclass
user_defined_keyword = {
    "#" ~ (identifier ~ ("::" ~ identifier)*)
}

// Elements

// Base element with optional names
element = {
    ("<" ~ identifier ~ ">")? ~ identifier?
}

// Namespace contains other elements
namespace = {
    prefix_metadata? ~
    namespace_token ~ identification? ~
    namespace_body
}

// Namespace Body
namespace_body = {
    ";" | ("{" ~ namespace_body_elements ~ "}")
}

// Namespace body elements already defined below at line ~690

// Non-Feature Member
non_feature_member = {
    visibility_kind? ~ non_feature_element
}

// Namespace Feature Member (OwnedFeatureMember in official grammar)
namespace_feature_member = {
    visibility_kind? ~ feature_element
}

// Type Feature Member (TypeFeatureMember in official grammar)
// 'member' keyword indicates the feature is a member of the type, not owned
type_feature_member = {
    visibility_kind? ~ member_token ~ feature_element
}

// Relationship Member
relationship_member = {
    visibility_kind? ~ relationship_element
}

// Annotating Member
annotating_member = {
    visibility_kind? ~ annotating_element
}

// Alias Member
alias_member = {
    visibility_kind? ~
    alias_token ~ identification? ~
    for_token ~ element_reference ~
    relationship_body
}

// Prefix Metadata (shorthand for metadata annotations)
prefix_metadata = {
    user_defined_keyword+
}

// Namespace Elements - Union Types

// RelationshipElement - union of relationship types
relationship_element = {
    dependency
    | standalone_specialization
    | standalone_conjugation
    | conjugation
    | standalone_feature_typing
    | subclassification
    | disjoining
    | feature_inverting
    | standalone_subsetting
    | standalone_redefinition
    | type_featuring
}

// NonFeatureElement - union of namespace types
non_feature_element = {
    namespace
    | package
    | library_package
    | multiplicity
    | type_def
    | classifier
    | class
    | structure
    | metaclass
    | data_type
    | association
    | association_structure
    | interaction
    | behavior
    | function
    | predicate
}

// FeatureElement - union of feature types
feature_element = {
    end_feature
    | feature
    | step
    | expression
    | boolean_expression
    | invariant
    | connector
    | binding_connector
    | succession
    | item_flow
    | succession_item_flow
}

// Type Relationships - relationships specific to types
type_relationship = {
    unioning
    | differencing
    | disjoining
    | intersecting
}

// Heritage - inheritance-based relationships for types
heritage = {
    specialization
    | reference_subsetting
    | subsetting
    | redefinition
    | cross_subsetting
    | conjugation
}

// Feature Relationships - relationships specific to features
feature_relationship = {
    type_relationship
    | feature_typing
    | feature_chaining
    | owned_feature_inverting
    | type_featuring
}

// Unified: Any type/feature relationship (heritage, type, or feature)
any_relationship = { heritage | type_relationship | feature_relationship }

// Unified: Feature or feature chain reference
feature_or_chain = { owned_feature_chain | element_reference }

// Multiplicity Bounds - the [lower..upper] syntax
multiplicity_bounds = {
    "[" ~ multiplicity_bounds_range ~ "]"
}

multiplicity_bounds_range = {
    multiplicity_bound ~ (".." ~ multiplicity_bound)?
}

multiplicity_bound = {
    inline_expression | number | "*"
}

// Type extends Namespace
type_def = {
    prefix_metadata? ~
    abstract_marker? ~
    type_token ~ all_token? ~ identification? ~
    any_relationship* ~
    multiplicity? ~
    ordering_modifiers ~
    namespace_body
}

// Classifier extends Type
classifier = {
    prefix_metadata? ~
    abstract_marker? ~
    classifier_token ~ all_token? ~ identification? ~
    any_relationship* ~
    multiplicity? ~
    namespace_body
}

// DataType extends Classifier
data_type = {
    prefix_metadata? ~
    visibility_kind? ~
    abstract_marker? ~
    datatype_token ~ identification? ~
    all_token? ~
    classifier_relationships ~
    multiplicity? ~
    namespace_body
}

// Class extends Classifier
// ClassifierDeclaration: (all)? Identification? OwnedMultiplicity? (SuperclassingPart)? TypeRelationshipPart*
class = {
    prefix_metadata? ~
    visibility_kind? ~
    abstract_marker? ~
    class_token ~ all_token? ~ identification? ~
    multiplicity_bounds? ~
    classifier_relationships ~
    namespace_body
}

// Structure extends Class
structure = {
    prefix_metadata? ~
    visibility_kind? ~
    abstract_marker? ~
    struct_token ~ identification? ~
    all_token? ~
    multiplicity_bounds? ~
    classifier_relationships ~
    namespace_body
}

// Behavior extends Class
behavior = {
    prefix_metadata? ~
    visibility_kind? ~
    abstract_marker? ~
    behavior_token ~ identification? ~
    all_token? ~
    classifier_relationships ~
    multiplicity? ~
    namespace_body
}

// Association extends Classifier and Relationship
association = {
    prefix_metadata? ~
    visibility_kind? ~
    abstract_marker? ~
    assoc_token ~ identification? ~
    all_token? ~
    classifier_relationships ~
    multiplicity? ~
    namespace_body
}

// AssociationStructure extends Association and Structure
association_structure = {
    prefix_metadata? ~
    abstract_marker? ~
    assoc_token ~ struct_token ~ identification? ~
    all_token? ~
    classifier_relationships ~
    multiplicity? ~
    namespace_body
}

// Metaclass extends Structure
metaclass = {
    prefix_metadata? ~
    visibility_kind? ~
    abstract_marker? ~
    metaclass_token ~ identification? ~
    all_token? ~
    classifier_relationships ~
    multiplicity? ~
    namespace_body
}

// Function extends Behavior
function = {
    prefix_metadata? ~
    visibility_kind? ~
    abstract_marker? ~
    function_token ~ identification? ~
    all_token? ~
    classifier_relationships ~
    multiplicity? ~
    result_expression_membership? ~
    namespace_body
}

// Predicate extends Function
predicate = {
    prefix_metadata? ~
    abstract_marker? ~
    predicate_token ~ identification? ~
    all_token? ~
    classifier_relationships ~
    multiplicity? ~
    result_expression_membership? ~
    namespace_body
}

// Interaction extends Association and Behavior
interaction = {
    prefix_metadata? ~
    visibility_kind? ~
    abstract_marker? ~
    interaction_token ~ identification? ~
    all_token? ~
    classifier_relationships ~
    multiplicity? ~
    namespace_body
}

// Feature extends Type
feature = {
    prefix_metadata? ~
    visibility_kind? ~
    feature_direction_kind? ~
    feature_prefix_modifiers ~
    feature_token ~ all_token? ~ identification? ~
    feature_specialization_part? ~
    ordering_modifiers ~
    feature_relationship_part* ~
    feature_value? ~
    namespace_body
}

// FeatureRelationshipPart per official grammar: TypeRelationshipPart | ChainingPart | InvertingPart | TypeFeaturingPart
feature_relationship_part = {
    featuring | owned_feature_inverting | feature_chaining | type_relationship
}

// End feature with identification and multiplicity: const? end <id> [mult] feature ... or const? end [mult] feature <id> ...
// Per official grammar: EndFeaturePrefix = ( isConstant ?= 'const')? isEnd ?= 'end'
end_feature = {
    prefix_metadata? ~
    const_token? ~
    end_marker ~ (
        identification ~ multiplicity_bounds ~ multiplicity_properties? ~ feature_specialization_part? ~ feature_token ~ identification? ~ feature_specialization_part?  // end name [mult] ordered? nonunique? relationships? feature ...
        | identification ~ feature_specialization_part ~ feature_token ~ identification? ~ feature_specialization_part?                       // end name relationships feature ...
        | multiplicity_bounds ~ multiplicity_properties? ~ feature_token ~ identification? ~ feature_specialization_part?                     // end [mult] ordered? nonunique? feature name ...
    ) ~
    feature_value? ~
    namespace_body
}

feature_specialization_part = { specialization_part_content }

multiplicity_part = {
    multiplicity_bounds ~ multiplicity_properties?
    | multiplicity_properties
}

// MetadataFeature extends Feature and AnnotatingElement
// MetadataFeature per official grammar:
// MetadataFeature = PrefixMetadataMember* ( '@' | 'metadata' ) MetadataFeatureDeclaration 
//                   ( 'about' Annotation (',' Annotation)* )? MetadataBody
// MetadataFeatureDeclaration = ( Identification ( ':' | 'typed' 'by' ) )? MetadataTyping
// MetadataTyping = QualifiedName
// MetadataBody = ';' | '{' ... '}'
metadata_feature = {
    prefix_metadata? ~
    (at_symbol | metadata_token) ~
    (identification ~ (":" | typed_token ~ by_token))? ~
    qualified_reference_chain ~
    (about_token ~ annotation ~ ("," ~ annotation)*)? ~
    metadata_body
}

metadata_body = {
    ";"
    | "{" ~ metadata_body_element* ~ "}"
}

metadata_body_element = {
    non_feature_member
    | metadata_body_feature_member
    | alias_member
    | import
}

// MetadataBodyFeature per official grammar:
// 'feature'? ( ':>>' | 'redefines' )? OwnedRedefinition FeatureSpecializationPart? ValuePart? MetadataBody
// OwnedRedefinition = QualifiedName | FeatureChain
metadata_body_feature_member = {
    feature_token? ~ (redefines_operator)? ~
    feature_or_chain ~
    feature_specialization_part? ~
    feature_value? ~
    metadata_body
}

// Multiplicity extends Feature
multiplicity = {
    prefix_metadata? ~
    feature_direction_kind? ~
    (acp_modifier | member_token | const_modifier | derived | end_marker | variable_marker)* ~
    (multiplicity_token | feature_token) ~ identification? ~
    feature_specialization_part? ~
    feature_value? ~
    namespace_body
}

// MultiplicityRange extends Multiplicity
multiplicity_range = {
    multiplicity ~
    owning_membership?
}

// ItemFeature extends Feature
item_feature = {
    feature
}

// Step extends Feature
step = {
    prefix_metadata? ~
    feature_direction_kind? ~
    connector_feature_modifiers ~
    step_token ~ identification? ~
    feature_specialization_part? ~
    feature_value? ~
    membership? ~
    owning_membership? ~
    namespace_body
}

// Connector extends Feature and Relationship
// Connector endpoint definition for from/to clauses
// ConnectorEnd = [mult]? [Name '::>']? (QualifiedName | FeatureChain)
connector_endpoint = {
    multiplicity_bounds? ~ (name ~ references_operator)? ~ feature_or_chain
}

// Per official grammar:
//   Connector = FeaturePrefix 'connector' (FeatureDeclaration? ValuePart? | ConnectorDeclaration) TypeBody
//   BinaryConnectorDeclaration = (FeatureDeclaration? 'from' | 'all' 'from'?)? ConnectorEnd 'to' ConnectorEnd
// The FeatureDeclaration includes: redefines, typing, multiplicity, etc.
// Per official grammar:
//   BinaryConnectorDeclaration = ( FeatureDeclaration? 'from' | 'all' 'from'? )? ConnectorEnd 'to' ConnectorEnd
//   FeatureDeclaration includes 'all' as isSufficient flag
//   - Declaration is ONLY consumed if followed by 'from'
//   - Standalone 'all' can appear with optional 'from'
connector = {
    prefix_metadata? ~
    feature_direction_kind? ~
    connector_feature_modifiers ~
    connector_token ~ 
    (
        // Binary connector: [all? declaration from | all from?]? end to end
        // FeatureDeclaration includes FeatureRelationshipPart* (featuring, inverse of, chains)
        (all_token? ~ feature_declaration ~ feature_relationship_part* ~ from_token | all_token ~ from_token?)? ~ connector_endpoint ~ to_token ~ connector_endpoint
        // N-ary connector: [declaration] (end, end, ...)
        | feature_declaration ~ feature_relationship_part* ~ "(" ~ connector_endpoint ~ ("," ~ connector_endpoint)+ ~ ")"
        // Simple connector without endpoints
        | all_token? ~ feature_declaration ~ feature_relationship_part*
    ) ~
    ordering_modifiers ~
    feature_value? ~
    end_feature_membership* ~
    namespace_body
}

// ItemFlowEnd extends Feature
item_flow_end = {
    feature
}

// Succession extends Connector
// Per official grammar: succession [declaration] first end then end
succession = {
    prefix_metadata? ~
    feature_direction_kind? ~
    connector_feature_modifiers ~
    succession_token ~ all_token? ~ identification? ~
    feature_specialization_part? ~
    (
        (first_token ~ multiplicity_bounds? ~ feature_or_chain)
        | (multiplicity_bounds? ~ feature_or_chain)
    )? ~
    (then_token ~ multiplicity_bounds? ~ feature_or_chain)? ~
    ordering_modifiers ~
    feature_value? ~
    connector_body_suffix
}

// BindingConnector extends Connector
binding_connector = {
    prefix_metadata? ~
    feature_direction_kind? ~
    connector_feature_modifiers ~
    binding_token ~ (
        owned_feature_chain ~ ("=" ~ multiplicity_bounds? ~ feature_or_chain)
        | identification? ~ multiplicity_bounds? ~
          (
              feature_typing
              | ((featuring_token | of_token) ~ multiplicity_bounds? ~ feature_or_chain)
              | (multiplicity_bounds? ~ feature_or_chain)
          )? ~
          ("=" ~ multiplicity_bounds? ~ feature_or_chain)?
    ) ~
    ordering_modifiers ~
    feature_value? ~
    connector_body_suffix
}

// Expression extends Step
expression = {
    prefix_metadata? ~
    visibility_kind? ~
    feature_direction_kind? ~
    connector_feature_modifiers ~
    expr_token ~ identification? ~
    feature_specialization_part? ~
    feature_value? ~
    membership? ~
    owning_membership? ~
    result_expression_membership? ~
    namespace_body
}

// ItemFlow (Flow) per official grammar:
// Flow = FeaturePrefix 'flow' FlowDeclaration TypeBody
// FlowDeclaration = FeatureDeclaration? ValuePart? ('of' PayloadFeature)? ('from' FlowEnd 'to' FlowEnd)?
//                 | ('all')? FlowEnd 'to' FlowEnd
// FlowEnd = FlowEndSubsetting? FlowFeature
// FlowEndSubsetting = QualifiedName '.' | FeatureChainPrefix
item_flow = {
    prefix_metadata? ~
    feature_direction_kind? ~
    connector_feature_modifiers ~
    flow_token ~ (
        // Pattern 2: [all] FlowEnd 'to' FlowEnd (direct endpoints, no 'from')
        all_token? ~ flow_end ~ to_token ~ flow_end ~ namespace_body
        // Pattern 1: [declaration] [of payload] [from end to end]
        | feature_declaration ~
          feature_value? ~
          (of_token ~ element_reference)? ~
          (from_token ~ flow_end ~ to_token ~ flow_end)? ~
          ordering_modifiers ~
          end_feature_membership* ~
          namespace_body
    )
}

// FlowEnd = [prefix.] feature
// The prefix is a feature chain ending with '.'
flow_end = {
    (owned_feature_chain ~ ".")? ~ feature_or_chain
}

// SuccessionItemFlow extends ItemFlow and Succession
// Syntax: succession flow name[mult] of Type from endpoint to endpoint;
succession_item_flow = {
    prefix_metadata? ~
    visibility_kind? ~
    acp_modifier* ~
    succession_token ~ flow_token ~ identification? ~
    multiplicity_bounds? ~
    (of_token ~ element_reference)? ~
    feature_specialization_part? ~
    (from_token ~ feature_chain_expression)? ~
    (to_token ~ feature_chain_expression)? ~
    ordering_modifiers ~
    feature_value? ~
    end_feature_membership* ~
    type_body
}

// BooleanExpression extends Expression
boolean_expression = {
    expression
}

// Invariant extends BooleanExpression
invariant = {
    prefix_metadata? ~
    inv_token ~ not_token? ~ identification? ~
    (namespace_body | ("{" ~ operator_expression ~ "}"))
}

// Package extends Namespace
package = {
    prefix_metadata? ~
    package_token ~ identification? ~
    namespace_body
}

// LibraryPackage extends Package
library_package = {
    standard_marker?
    ~ library_token
    ~ prefix_metadata?
    ~ package_token ~ identification?
    ~ namespace_body
}

// Relationships

// Base relationship with visibility and references
relationship = {
    visibility_kind? ~
    element_reference ~
    ("::" ~ element_reference)?
}

// Inheritance - base for inheriting relationships
inheritance = {
    relationship
}

// Unioning extends Relationship
unioning = {
    unions_token ~ relationship ~ ("," ~ relationship)*
}

// Differencing extends Relationship (official grammar uses 'differences' keyword)
differencing = {
    differences_token ~ relationship ~ ("," ~ relationship)*
}

// Intersecting extends Relationship
intersecting = {
    intersects_token ~ relationship ~ ("," ~ relationship)*
}

// FeatureChaining extends Relationship
feature_chaining = {
    chains_token ~ ((identifier ~ ("." ~ identifier)+) | qualified_reference_chain | relationship)
}

// Specialization extends Inheritance (inline form used in heritage)
specialization = {
    specializes_operator ~ inheritance ~ ("," ~ inheritance)*
}

// Standalone Specialization - top-level 'subtype' keyword form per official grammar
// ( 'specialization' Identification? )? 'subtype' FeatureChain ( ':>' | 'specializes' ) FeatureChain RelationshipBody
standalone_specialization = {
    specialization_prefix ~
    subtype_token ~ feature_or_chain ~
    specializes_operator ~ feature_or_chain ~
    relationship_body
}

// Disjoining extends Relationship
disjoining = {
    disjoint_token ~ (
        element_reference ~ from_token ~ element_reference  // disjoint a.b from c.d
        | from_token ~ relationship                          // disjoint from X
        | visibility_kind? ~ element_reference            // disjoint Type1 or disjoint private Type2
    )
}

// FeatureInverting per official grammar (standalone form):
// ( 'inverting' Identification? )? 'inverse' FeatureChain 'of' FeatureChain RelationshipBody
feature_inverting = {
    (inverting_token ~ identification?)? ~
    inverse_token ~ feature_or_chain ~
    of_token ~ feature_or_chain ~
    relationship_body
}

// OwnedFeatureInverting per official grammar (inline form in feature declarations):
// 'inverse' 'of' (QualifiedName | FeatureChain)
owned_feature_inverting = {
    inverse_token ~ of_token ~ feature_or_chain
}

// Featuring extends Relationship
// Syntax: featured by TypeName
featuring = {
    featured_token ~ by_token ~ element_reference
}

// TypeFeaturing per official grammar:
// 'featuring' ( Identification? 'of')? featureOfType 'by' featuringType RelationshipBody
type_featuring = {
    featuring_token ~
    (identification? ~ of_token)? ~
    element_reference ~
    by_token ~ element_reference ~
    relationship_body
}

// FeatureTyping per official grammar (inline form):
// TypedBy (',' OwnedFeatureTyping)*
// OwnedFeatureTyping = QualifiedName | FeatureChain
feature_typing = {
    typed_by_operator ~ feature_type ~ ("," ~ feature_type)*
}

// Standalone FeatureTyping per official grammar:
// ( 'specialization' Identification? )? 'typing' typedFeature (':' | 'typed' 'by') FeatureType RelationshipBody
standalone_feature_typing = {
    specialization_prefix ~
    typing_token ~
    element_reference ~
    typed_by_operator ~
    feature_type ~
    relationship_body
}

// FeatureType = QualifiedName | FeatureChain
feature_type = { feature_or_chain }

// Subclassification extends Specialization
// Subclassification per official grammar:
// ( 'specialization' Identification? )? 'subclassifier' subclassifier (':>' | 'specializes') superclassifier RelationshipBody
subclassification = {
    specialization_prefix ~
    subclassifier_token ~ element_reference ~
    specializes_operator ~ element_reference ~
    relationship_body
}

// Subsetting extends Specialization (inline form used in heritage)
subsetting = {
    subsets_operator ~ inheritance ~ ("," ~ inheritance)*
}

// Standalone Subsetting - top-level 'subset' keyword form per official grammar
// ( 'specialization' Identification? )? 'subset' FeatureChain ( ':>' | 'subsets' ) FeatureChain RelationshipBody
standalone_subsetting = {
    specialization_prefix ~
    subset_token ~ feature_or_chain ~
    subsets_operator ~ feature_or_chain ~
    relationship_body
}

// Standalone Redefinition - top-level 'redefinition' keyword form per official grammar
// ( 'specialization' Identification? )? 'redefinition' FeatureChain ( ':>>' | 'redefines' ) FeatureChain RelationshipBody
standalone_redefinition = {
    specialization_prefix ~
    redefinition_token ~ feature_or_chain ~
    redefines_operator ~ feature_or_chain ~
    relationship_body
}

// Conjugation extends Inheritance (inline form: ~ Type)
conjugation = {
    conjugates_operator ~ inheritance
}

// Standalone Conjugation per official grammar:
// ('conjugation' Identification?)? 'conjugate' type1 ('~' | 'conjugates') type2 RelationshipBody
standalone_conjugation = {
    (conjugation_token ~ identification?)? ~
    conjugate_token ~ feature_or_chain ~
    conjugates_operator ~ feature_or_chain ~
    relationship_body
}

// Redefinition extends Subsetting (inline form used in heritage)
redefinition = {
    redefines_operator ~ inheritance ~ ("," ~ inheritance)*
}

// ReferenceSubsetting extends Subsetting
reference_subsetting = {
    references_operator ~ inheritance
}

// CrossSubsetting extends Subsetting
cross_subsetting = {
    crosses_operator ~ inheritance
}

// Dependency extends Relationship
dependency = {
    user_defined_keyword* ~
    dependency_token ~ (identification? ~ from_token)? ~
    element_reference ~ ("," ~ element_reference)* ~ to_token ~
    element_reference ~ ("," ~ element_reference)* ~
    relationship_body
}

// Import extends Relationship

// Import prefix fragment
import_prefix = {
    visibility_kind? ~ import_token ~ import_all?
}

// Imported reference with namespace and recursive flags
imported_reference = {
    element_reference ~ import_kind?
}

// Import with optional filter package
import = {
    import_prefix ~
    imported_reference ~
    filter_package? ~
    relationship_body
}

// Filter Package
filter_package = {
    filter_package_member+
}

// Filter Package Member
filter_package_member = {
    "[" ~ operator_expression ~ "]"
}

// Note: owned_expression is defined in kerml_expressions.pest (shared with SysML)

// MembershipImport extends Import
membership_import = {
    import
}

// NamespaceImport extends Import
namespace_import = {
    import
}

// Membership extends Relationship
membership = {
    visibility_kind? ~
    alias_token? ~
    element_reference?
}

// OwningMembership extends Membership
owning_membership = {
    inline_expression | membership
}

// FeatureValue extends OwningMembership
feature_value = {
    ("=" | ":=" | default_token) ~
    owning_membership
}

// ElementFilterMembership per official grammar:
// MemberPrefix 'filter' OwnedExpression ';'
element_filter_membership = {
    filter_token ~ operator_expression ~ ";"
}

// FeatureMembership extends Featuring and OwningMembership
feature_membership = {
    featuring ~
    owning_membership
}

// EndFeatureMembership extends FeatureMembership
end_feature_membership = {
    end_token ~ (
        typed_feature_member
        | feature_membership
    )
}

// ParameterMembership extends FeatureMembership
// Simplified: direction identifier : type[mult] ;
// Or: direction featuretype identifier[mult] { body }
parameter_membership = {
    feature_direction_kind ~ (
        name_identifier ~ identifier ~ parameter_specialization_part? ~ feature_value?  // type + name
        | identifier ~ parameter_specialization_part? ~ feature_value?  // just name
        | name_identifier ~ parameter_specialization_part ~ feature_value?  // type + relationships
        | parameter_specialization_part ~ feature_value?  // just relationships
    ) ~ type_body
}

parameter_specialization_part = {
    (feature_typing | heritage)+ ~ multiplicity_part ~ (feature_typing | heritage)*
    | (feature_typing | heritage)+
    | multiplicity_part ~ (feature_typing | heritage)*
    | multiplicity_part
}

// ResultExpressionMembership extends FeatureMembership
result_expression_membership = {
    return_token ~ feature_membership
}

// ReturnParameterMembership extends ParameterMembership
// Simplified: return : type[mult] default expr ;
return_parameter_membership = {
    return_token ~ feature_token? ~ (
        identifier ~ parameter_specialization_part? ~ (("=" | default_token) ~ inline_expression)?
        | parameter_specialization_part ~ (("=" | default_token) ~ inline_expression)?
    ) ~ type_body
}

// References

// QualifiedReferenceChain - name::name::name or name.name.name pattern
// Uses 'name' to allow both regular identifiers and quoted names like 'not'
// GlobalQualification: '$::' prefix for root namespace references
global_qualification = { "$" ~ "::" }
qualified_reference_chain = {
    global_qualification ~ (name ~ "::")* ~ name ~ ("." ~ name)*
    | name ~ ("::" ~ name | "." ~ name)*
}

// ElementReference - base reference type
element_reference = {
    qualified_reference_chain
}

// NamespaceReference extends ElementReference
namespace_reference = {
    qualified_reference_chain
}

// TypeReference extends NamespaceReference
type_reference = {
    qualified_reference_chain
}

// ClassifierReference extends TypeReference
classifier_reference = {
    qualified_reference_chain
}

// FeatureReference extends TypeReference
feature_reference = {
    qualified_reference_chain
}

// MetaclassReference extends ClassifierReference
metaclass_reference = {
    qualified_reference_chain
}

// MembershipReference extends ElementReference
membership_reference = {
    qualified_reference_chain
}

// Literal Expressions

literal_boolean = {
    false_token | true_token
}

literal_string = {
    string_value
}

literal_char = {
    char_value
}

literal_number = {
    number
}

literal_infinity = {
    "*"
}

literal_expression = {
    literal_boolean
    | literal_string
    | literal_char
    | literal_number
    | literal_infinity
}

// Null Expression
null_expression = {
    null_token | ("(" ~ ")")
}

// =============================================================================
// EXPRESSION CHAIN
// The core expression precedence chain (owned_expression through unary_expression)
// is defined in kerml_expressions.pest and shared with SysML.
// Below are KerML-specific extension points referenced by that chain.
// =============================================================================

// OperatorExpression - alias for owned_expression for backwards compatibility
operator_expression = {
    owned_expression
}

// Classification Expressions (KerML-specific: includes @@ for metadata)
// Per official grammar: 'meta' is MetaCastOperator for metadata type casting
// '@TypeName' is a shorthand with implicit self operand (like 'self @ TypeName')
classification_expression = {
    classification_test_operator ~ type_reference              // @Structure (implicit self)
    | relational_expression ~ ((as_token | meta_token | classification_test_operator) ~ type_reference)?
}

// ExtentExpression per official grammar: 'all' TypeReference | PrimaryExpression
extent_expression = {
    all_token ~ type_reference
    | collect_operator_expression
}

// Collect Operator Expressions (-> for collection operations, . for feature chaining, # for indexing)
// Also handles shorthand collect `.{` and shorthand select `.?{` per official grammar
collect_operator_expression = {
    primary_expression ~ (
        ("." ~ "?" ~ "{" ~ body_expression_body ~ "}")  // shorthand select: x.?{...}
        | ("." ~ "{" ~ body_expression_body ~ "}")      // shorthand collect: x.{...}
        | ("." ~ identifier)                            // feature chaining: x.y
        | (arrow_operator ~ identifier ~ collect_operation_args?)  // explicit: x->collect {...}
        | ("#" ~ "(" ~ operator_expression ~ ("," ~ operator_expression)* ~ ")")  // indexing: x#(1)
    )*
}

arrow_operator = @{ "->" }

// Body of a body expression (shared by collect/select)
body_expression_body = {
    (in_token ~ name_identifier ~ (":" ~ type_reference)? ~ ";")+ ~ operator_expression
    | in_token ~ name_identifier ~ (":" ~ type_reference)? ~ ";" ~ operator_expression
    | operator_expression
}

collect_operation_args = {
    "{" ~ in_token ~ name_identifier ~ feature_typing ~ ";" ~ operator_expression ~ "}"
    | "{" ~ parameter_membership+ ~ operator_expression ~ "}"
    | "{" ~ operator_expression ~ "}"
    | "(" ~ (operator_expression ~ ("," ~ operator_expression)*)? ~ ")"
    | operator_expression
}

// Primary Expressions
primary_expression = {
    "(" ~ operator_expression ~ ("," ~ operator_expression)* ~ ")"
    | invocation_primary
    | feature_reference_creation
    | literal_expression
    | null_expression
    | feature_reference_expression
}

feature_reference_creation = {
    new_token ~ qualified_reference_chain ~ "(" ~ (operator_expression ~ ("," ~ operator_expression)*)? ~ ")"
}

invocation_primary = {
    qualified_reference_chain ~ "(" ~ (operator_expression ~ ("," ~ operator_expression)*)? ~ ")"
}

// InvocationExpression - now handled within operator_expression hierarchy
invocation_expression = {
    operator_expression
}

// FeatureChainExpression - now handled within operator_expression hierarchy
feature_chain_expression = {
    operator_expression
}

// IndexExpression - array/collection indexing (e.g., arr[0])
index_expression = {
    // Placeholder: Will be expanded with indexing syntax
    operator_expression ~ ("[" ~ operator_expression ~ "]")*
}

// CollectExpression - collection operation
collect_expression = {
    // Placeholder: Will be expanded with collection syntax
    operator_expression
}

// SelectExpression - filtering operation
select_expression = {
    // Placeholder: Will be expanded with selection syntax
    operator_expression
}

// Metadata and Feature Typing

metadata_typing = {
    metaclass_reference
}

owned_feature_typing = {
    type_reference | owned_feature_chain
}

// Classification Expressions

metadata_reference = {
    element_reference
}

type_reference_member = {
    type_reference_feature
}

type_result_member = {
    type_reference_feature
}

type_reference_feature = {
    reference_typing
}

reference_typing = {
    type_reference
}

// Self Reference Expressions

self_reference_expression = {
    self_reference_member
}

self_reference_member = {
    empty_feature
}

empty_feature = {
    // Empty production - represents implicit self reference
    ""
}

// Primary Expressions

function_reference_expression = {
    function_reference_member
}

function_reference_member = {
    function_reference
}

function_reference = {
    reference_typing
}

feature_chain_member = {
    feature_reference | owned_feature_chain
}

// Invocation Expressions

owned_feature_chain = {
    identifier ~ ("." ~ identifier)+
}

feature_chaining_expr = {
    feature_reference
}

feature_chain_prefix = {
    (feature_chaining_expr ~ ".")+ ~ feature_chaining_expr ~ "."
}

owned_feature_chaining = {
    feature_reference
}

// Feature Reference Expressions

feature_reference_expression = {
    feature_reference_member
}

feature_reference_member = {
    feature_reference
}

// Metadata Access Expressions

metadata_access_expression = {
    element_reference ~ "." ~ metadata_token
}

// Relationship Body Fragments

relationship_body = {
    ";" | ("{" ~ relationship_owned_elements ~ "}")
}

relationship_owned_elements = {
    relationship_owned_element*
}

relationship_owned_element = {
    owned_annotation
    | feature_element
    | non_feature_element
    | relationship_element
}

// Namespace Body Elements

namespace_body_elements = {
    namespace_body_element*
}

namespace_body_element = {
    import
    | alias_member
    | annotating_member
    | parameter_membership
    | return_parameter_membership
    | end_feature_membership
    | element_filter_membership
    | type_feature_member
    | namespace_feature_member
    | non_feature_member
    | typed_feature_member
    | subset_member
    | prefix_metadata_feature_member
    | shorthand_feature_member
    | relationship_member
    | operator_expression
}

// Shorthand feature member without 'feature' keyword
shorthand_feature_member = {
    visibility_kind? ~
    (
        identification ~ feature_typing? ~ any_relationship* ~ feature_value?
        | any_relationship+ ~ feature_value?
    ) ~
    ";"
}

// Feature member with prefix metadata instead of 'feature' keyword
// Per official grammar: modifiers* #MetaName+ declaration
// Examples: abstract #Classified z2; or #Security feature z;
prefix_metadata_feature_member = {
    visibility_kind? ~
    (abstract_token | composite_token | portion_token | const_modifier | derived | end_marker | variable_marker)* ~
    prefix_metadata ~
    identification? ~
    feature_specialization_part? ~
    feature_value? ~
    type_body
}

// Subset member shorthand: subset x.y subsets a.b;
subset_member = {
    subset_token ~ qualified_reference_chain ~ any_relationship+ ~ ";"
}

// Typed feature shorthand: <type> <name>? <relationships>* <mult>? <body>
// e.g., "bool monitoredOccurrence[1] { }" or "protected bool redefines x {}"
// Allows multiplicity before or after relationships
typed_feature_member = {
    visibility_kind? ~
    name_identifier ~ // Type reference (can be keyword like "bool")
    identification? ~ // Optional feature name
    optional_specialization_part ~
    feature_value? ~
    namespace_body
}

// Root Namespace Entry Point

root_namespace = {
    SOI ~ namespace_body_elements ~ EOI
}

// Entry point for parsing KerML files
file = { SOI ~ namespace_element* ~ EOI }

namespace_element = {
    package
    | library_package
    | import
    | alias_member
    | annotating_member
    | namespace_feature_member
    | non_feature_member
    | relationship_member
}
