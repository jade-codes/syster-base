#!/usr/bin/env python3
"""
Extract all test input strings from archived test files.

This script deterministically extracts SysML/KerML code samples from .archived
test files. It can be re-run at any time to regenerate TEST_DATA_COMPLETE.md.

Usage:
    cd base/tests && python3 extract_test_data.py

Output:
    TEST_DATA_COMPLETE.md - Contains all extracted code samples organized by source file

The script filters out:
- File names (*.kerml, *.sysml, etc.)
- Assertion messages ("should be", "expected", etc.)
- Pure descriptions (no code syntax characters)
- Error messages about unsupported features

And keeps:
- Single-line SysML/KerML statements
- Multi-line code blocks
- Test function names for reference
"""

import re
import os
from pathlib import Path
from collections import defaultdict

def extract_rust_strings(content: str) -> list[str]:
    """Extract all Rust string literals (regular and raw strings)."""
    strings = []
    
    # Raw strings: r#"..."#, r##"..."##, etc.
    raw_pattern = r'r(#*)"(.*?)"\1'
    for match in re.finditer(raw_pattern, content, re.DOTALL):
        strings.append(match.group(2))
    
    # Regular strings (handle escapes minimally)
    # Match "..." but not inside raw strings
    regular_pattern = r'(?<!r)(?<!r#)(?<!r##)"([^"\\]*(\\.[^"\\]*)*)"'
    for match in re.finditer(regular_pattern, content):
        s = match.group(1)
        # Unescape common escapes
        s = s.replace('\\n', '\n').replace('\\t', '\t').replace('\\"', '"').replace('\\\\', '\\')
        if s.strip():
            strings.append(s)
    
    return strings

def extract_test_inputs(file_path: Path) -> dict[str, list[str]]:
    """Extract test inputs organized by test function."""
    content = file_path.read_text()
    results = defaultdict(list)
    
    # Find all test functions
    test_pattern = r'#\[test\]\s*fn\s+(\w+)\s*\(\s*\)\s*\{([^}]*(?:\{[^}]*\}[^}]*)*)\}'
    
    # Simpler approach: find all strings that look like SysML/KerML code
    all_strings = extract_rust_strings(content)
    
    sysml_kerml_keywords = [
        'package', 'part', 'port', 'action', 'state', 'item', 'attribute',
        'classifier', 'class', 'struct', 'datatype', 'behavior', 'function',
        'predicate', 'interaction', 'assoc', 'feature', 'import', 'specializes',
        'subsets', 'redefines', ':>', ':>>', 'def', 'abstract', 'library',
        'standard', 'calc', 'constraint', 'requirement', 'connection', 'interface',
        'flow', 'allocation', 'view', 'viewpoint', 'rendering', 'metadata',
        'occurrence', 'enum', 'analysis', 'verification', 'use case', 'concern',
        'fork', 'join', 'merge', 'decide', 'entry', 'exit', 'do', 'accept',
        'transition', 'succession', 'first', 'then', 'after', 'send', 'via',
        'expose', 'dependency', 'comment', 'doc', 'alias', 'namespace', 'type',
        'in ', 'out ', 'inout ', 'ref ', 'readonly ', 'derived ', 'variation ',
        'assert ', 'assume ', 'require ', 'satisfy ', 'verify ', 'exhibit ',
        'subject ', 'actor ', 'stakeholder ', 'objective '
    ]
    
    for s in all_strings:
        s_lower = s.lower().strip()
        # Check if it looks like SysML/KerML code
        if any(kw in s_lower for kw in sysml_kerml_keywords):
            # Skip if it's clearly a file path or error message
            if not s.startswith('/') and not 'error' in s_lower and not 'expected' in s_lower:
                results['code_samples'].append(s.strip())
    
    return results

def extract_indented_strings(file_path: Path) -> list[str]:
    """Extract indented string literals (often multi-line test inputs)."""
    content = file_path.read_text()
    results = []
    
    # Find indented raw strings with SysML/KerML content
    # Pattern for indented multiline strings
    lines = content.split('\n')
    in_raw_string = False
    current_string = []
    
    for line in lines:
        if 'r#"' in line or 'r##"' in line:
            in_raw_string = True
            # Extract content after r#"
            match = re.search(r'r#+"(.*)$', line)
            if match:
                current_string.append(match.group(1))
        elif in_raw_string:
            if '"#' in line:
                # End of raw string
                match = re.search(r'^(.*)"#+', line)
                if match:
                    current_string.append(match.group(1))
                results.append('\n'.join(current_string))
                current_string = []
                in_raw_string = False
            else:
                current_string.append(line)
    
    return results

def main():
    test_dir = Path(__file__).parent
    archived_files = sorted(test_dir.glob('*.archived'))
    
    output = []
    output.append("# Complete Extracted Test Data from Archived Tests\n")
    output.append("This file contains ALL test input strings extracted programmatically.\n")
    output.append("Generated by extract_test_data.py\n")
    output.append("=" * 80 + "\n")
    
    for archived_file in archived_files:
        print(f"Processing {archived_file.name}...")
        output.append(f"\n## {archived_file.name}\n")
        
        content = archived_file.read_text()
        
        # Extract all raw strings (most reliable for code samples)
        raw_strings = []
        
        # r#"..."# pattern
        for match in re.finditer(r'r#"(.*?)"#', content, re.DOTALL):
            s = match.group(1).strip()
            if s and len(s) > 3:  # Skip trivial strings
                raw_strings.append(s)
        
        # r##"..."## pattern  
        for match in re.finditer(r'r##"(.*?)"##', content, re.DOTALL):
            s = match.group(1).strip()
            if s and len(s) > 3:
                raw_strings.append(s)
        
        # Regular strings - be more aggressive
        # Match quoted strings that aren't inside comments
        for match in re.finditer(r'"([^"\\]*(?:\\.[^"\\]*)*)"', content):
            s = match.group(1).strip()
            if s and len(s) > 3:
                # Unescape
                s = s.replace('\\n', '\n').replace('\\t', '\t').replace('\\"', '"').replace('\\\\', '\\')
                raw_strings.append(s)
        
        # Also look for indented string continuations (indoc style)
        for match in re.finditer(r'indoc!\s*\{([^}]+)\}', content, re.DOTALL):
            s = match.group(1).strip()
            if s:
                raw_strings.append(s)
        
        # Deduplicate while preserving order
        seen = set()
        unique_strings = []
        for s in raw_strings:
            normalized = s.strip()
            if normalized and normalized not in seen:
                seen.add(normalized)
                unique_strings.append(normalized)
        
        # Filter to likely SysML/KerML code
        sysml_kerml_indicators = [
            'package', 'part', 'port', 'action', 'state', 'item', 'attribute',
            'classifier', 'class', 'struct', 'datatype', 'behavior', 'function',
            'predicate', 'interaction', 'assoc', 'feature', 'import', 'specializes',
            'def ', 'abstract', 'library', 'standard', 'calc', 'constraint',
            'requirement', 'connection', 'interface', 'flow', 'allocation',
            'view', 'viewpoint', 'rendering', 'metadata', 'occurrence', 'enum',
            'fork', 'join', 'merge', 'decide', 'entry', 'exit', 'transition',
            'succession', 'dependency', 'comment', 'doc', 'alias', 'namespace',
            'type ', 'in ', 'out ', 'inout ', ':>', ':>>', 'subsets', 'redefines',
        ]
        
        # Strings that indicate assertion messages, not code
        assertion_indicators = [
            'should', 'expected', 'failed', 'must be', 'cannot', 'invalid',
            'could not', 'unable', 'parsing', 'first member', 'second member',
            'is abstract', 'should be', 'should have', 'should not', 'member should',
            'convert to',
        ]
        
        # Skip file names
        file_extensions = ['.kerml', '.sysml', '.rs', '.md', '.txt', '.json']
        
        # Keywords that start actual code
        code_starters = [
            'package', 'part', 'port', 'action', 'state', 'item', 
            'attribute', 'classifier', 'class', 'struct', 'datatype',
            'behavior', 'function', 'predicate', 'interaction', 'assoc',
            'feature', 'import', 'library', 'standard', 'abstract',
            'calc', 'constraint', 'requirement', 'connection', 'interface',
            'flow', 'allocation', 'view', 'viewpoint', 'rendering',
            'metadata', 'occurrence', 'enum', 'fork', 'join', 'merge',
            'decide', 'entry', 'exit', 'transition', 'succession',
            'dependency', 'comment', 'doc', 'alias', 'namespace', 'type',
            'in', 'out', 'inout', 'ref', 'readonly', 'derived', 'variation',
            'assert', 'assume', 'require', 'satisfy', 'verify', 'exhibit',
            'subject', 'actor', 'stakeholder', 'objective', 'private',
            'protected', 'public', 'first', 'then', 'after', 'accept',
            'if', 'send', 'expose', 'bind', 'variant', 'timeslice',
            'snapshot', 'individual', 'ordered', 'nonunique',
            'end', 'connector', 'binding', 'inv', 'expr', 'step',
            'metaclass', 'disjoining', 'disjoint', 'unions', 'intersects',
            'differences', 'conjugates', 'conjugation', 'inverting',
            'redefinition', 'specialization', 'subset', 'subtype', '~',
            'perform', 'include', 'message', 'loop', 'parallel',
            'use', 'concern', 'analysis', 'verification',
            'render', 'terminate', 'assign', 'return', 'cross',
        ]
        
        code_samples = []
        for s in unique_strings:
            s_lower = s.lower()
            # Skip file names
            if any(s_lower.endswith(ext) for ext in file_extensions):
                continue
            # Skip obvious descriptions (start with lowercase, contain "with")
            if s[0].islower() and ' with ' in s_lower and not any(s.startswith(kw) for kw in ['in ', 'out ', 'inout ', 'ref ']):
                continue
            # Skip pure descriptions (all lowercase, no special chars)
            if s[0].islower() and not any(c in s for c in [':', ';', '{', '}', '(', ')', '[', ']', ':>', '::']) and ' ' in s:
                continue
            # Skip error/description messages
            skip_phrases = ['not yet supported', 'Function calls in', 'Return with', 'Domain calc def', 'calculation1']
            if any(phrase in s for phrase in skip_phrases):
                continue
            # Must have SysML/KerML indicator
            if not any(ind in s_lower for ind in sysml_kerml_indicators):
                continue
            # Check if it looks like an assertion message
            if any(ind in s_lower for ind in assertion_indicators):
                # Only include if it starts with a code keyword
                first_word = s.split()[0].lower() if s.split() else ''
                if first_word not in code_starters:
                    continue
            code_samples.append(s)
        
        if code_samples:
            output.append(f"\n### Code Samples ({len(code_samples)} total)\n")
            for i, sample in enumerate(code_samples, 1):
                if '\n' in sample:
                    output.append(f"\n#### Sample {i}\n```\n{sample}\n```\n")
                else:
                    output.append(f"- `{sample}`")
        else:
            output.append("\n*No SysML/KerML code samples found*\n")
        
        # Also extract test names for reference
        test_names = re.findall(r'#\[test\]\s*fn\s+(\w+)', content)
        if test_names:
            output.append(f"\n### Test Functions ({len(test_names)} total)")
            for name in test_names:
                output.append(f"- {name}")
    
    # Write output
    output_path = test_dir / "TEST_DATA_COMPLETE.md"
    output_path.write_text('\n'.join(output))
    print(f"\nWritten to {output_path}")
    print(f"Total archived files processed: {len(archived_files)}")

if __name__ == '__main__':
    main()
