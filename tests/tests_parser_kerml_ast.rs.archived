//! KerML AST layer tests for Rowan parser.
//!
//! These tests verify that the typed AST wrappers correctly extract
//! semantic information from the untyped Rowan CST.
//!
//! Adapted from tests_parser_kerml_pest.rs.disabled
//!
//! Run with: `cargo test --test tests_parser_kerml_ast`

use rstest::rstest;
use syster::parser::ast::{
    AstNode, DefinitionKind, Direction, NamespaceMember, SourceFile, SpecializationKind,
};
use syster::parser::parse_kerml;

// ============================================================================
// Test Helpers - Transform arrange/act for Rowan parser
// ============================================================================

/// Helper: Parse KerML input and return SourceFile AST
fn parse_source(input: &str) -> SourceFile {
    let parsed = parse_kerml(input);
    SourceFile::cast(parsed.syntax()).expect("Failed to cast to SourceFile")
}

/// Helper: Assert that KerML input parses without fatal errors
/// Returns the parse result for further inspection
fn assert_parses(input: &str) -> syster::parser::Parse {
    let parsed = parse_kerml(input);
    // Allow recoverable errors, but the tree should exist
    assert!(
        !parsed.syntax().text().is_empty(),
        "Parse produced empty tree for: {}",
        input
    );
    parsed
}

/// Helper: Assert KerML parses and produces expected number of top-level members
fn assert_parses_with_members(input: &str, expected_count: usize) -> SourceFile {
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();
    assert_eq!(
        members.len(),
        expected_count,
        "Expected {} members for input: {}",
        expected_count,
        input
    );
    file
}

/// Helper: Assert a definition parses with expected kind and name
fn assert_definition(input: &str, expected_kind: DefinitionKind, expected_name: &str) {
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();
    assert!(!members.is_empty(), "No members parsed for: {}", input);

    match &members[0] {
        NamespaceMember::Definition(def) => {
            assert_eq!(
                def.definition_kind(),
                Some(expected_kind),
                "Wrong definition kind for: {}",
                input
            );
            assert_eq!(
                def.name().and_then(|n| n.text()),
                Some(expected_name.to_string()),
                "Wrong name for: {}",
                input
            );
        }
        other => panic!("Expected Definition, got {:?} for: {}", other, input),
    }
}

// ============================================================================
// Definition Kind Tests - Parameterized
// ============================================================================

#[rstest]
#[case("classifier MyClassifier;", DefinitionKind::Classifier, "MyClassifier")]
#[case("abstract classifier Vehicle;", DefinitionKind::Classifier, "Vehicle")]
#[case("class MyClass;", DefinitionKind::Class, "MyClass")]
#[case("abstract class Occurrence;", DefinitionKind::Class, "Occurrence")]
#[case("struct MyStruct;", DefinitionKind::Struct, "MyStruct")]
#[case("datatype Real;", DefinitionKind::DataType, "Real")]
#[case("datatype Boolean;", DefinitionKind::DataType, "Boolean")]
#[case("behavior MyBehavior;", DefinitionKind::Behavior, "MyBehavior")]
#[case("function calculateArea;", DefinitionKind::Function, "calculateArea")]
#[case("function sum;", DefinitionKind::Function, "sum")]
#[case("predicate MyPredicate;", DefinitionKind::Predicate, "MyPredicate")]
#[case("interaction MyInteraction;", DefinitionKind::Interaction, "MyInteraction")]
#[case("metaclass MyMetaclass;", DefinitionKind::Metaclass, "MyMetaclass")]
fn test_definition_kinds(
    #[case] input: &str,
    #[case] expected_kind: DefinitionKind,
    #[case] expected_name: &str,
) {
    assert_definition(input, expected_kind, expected_name);
}

// ============================================================================
// Definition with Specialization Tests
// ============================================================================

#[rstest]
#[case("classifier Car specializes Vehicle;", "Car", "specializes")]
#[case("classifier SportsCar :> Car;", "SportsCar", ":>")]
#[case("class Occurrence specializes Anything;", "Occurrence", "specializes")]
#[case("datatype ScalarValue specializes DataValue;", "ScalarValue", "specializes")]
#[case("abstract class Base :> Root;", "Base", ":>")]
fn test_definition_with_specialization(
    #[case] input: &str,
    #[case] expected_name: &str,
    #[case] _spec_keyword: &str,
) {
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();

    match &members[0] {
        NamespaceMember::Definition(def) => {
            assert_eq!(
                def.name().and_then(|n| n.text()),
                Some(expected_name.to_string())
            );
            let specs: Vec<_> = def.specializations().collect();
            assert!(!specs.is_empty(), "Should have specialization for: {}", input);
        }
        _ => panic!("Expected Definition for: {}", input),
    }
}

// ============================================================================
// Abstract Modifier Tests
// ============================================================================

#[rstest]
#[case("abstract classifier Vehicle;", true)]
#[case("classifier Vehicle;", false)]
#[case("abstract class Base;", true)]
#[case("class Base;", false)]
#[case("abstract datatype ScalarValue;", true)]
#[case("datatype Real;", false)]
fn test_abstract_modifier(#[case] input: &str, #[case] expected_abstract: bool) {
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();

    match &members[0] {
        NamespaceMember::Definition(def) => {
            assert_eq!(
                def.is_abstract(),
                expected_abstract,
                "Abstract mismatch for: {}",
                input
            );
        }
        _ => panic!("Expected Definition for: {}", input),
    }
}

// ============================================================================
// Feature/Usage Tests - Direction
// ============================================================================

#[rstest]
#[case("function Test { in feature x; }", Direction::In)]
#[case("function Test { out feature x; }", Direction::Out)]
#[case("function Test { inout feature x; }", Direction::InOut)]
fn test_feature_direction(#[case] input: &str, #[case] expected_dir: Direction) {
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();

    match &members[0] {
        NamespaceMember::Definition(def) => {
            let nested: Vec<_> = def.members().collect();
            match &nested[0] {
                NamespaceMember::Usage(usage) => {
                    assert_eq!(
                        usage.direction(),
                        Some(expected_dir),
                        "Direction mismatch for: {}",
                        input
                    );
                }
                _ => panic!("Expected Usage for: {}", input),
            }
        }
        _ => panic!("Expected Definition for: {}", input),
    }
}

// ============================================================================
// Feature/Usage Tests - Typing
// ============================================================================

#[rstest]
#[case("package Test { feature mass : Real; }", "mass")]
#[case("package Test { feature x : Integer; }", "x")]
#[case("package Test { feature value : Boolean; }", "value")]
fn test_feature_with_typing(#[case] input: &str, #[case] expected_name: &str) {
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();

    match &members[0] {
        NamespaceMember::Package(pkg) => {
            let pkg_members: Vec<_> = pkg.members().collect();
            match &pkg_members[0] {
                NamespaceMember::Usage(usage) => {
                    assert_eq!(
                        usage.name().and_then(|n| n.text()),
                        Some(expected_name.to_string())
                    );
                    assert!(usage.typing().is_some(), "Should have typing for: {}", input);
                }
                _ => panic!("Expected Usage for: {}", input),
            }
        }
        _ => panic!("Expected Package for: {}", input),
    }
}

// ============================================================================
// Feature/Usage Tests - Specializations (subsets, redefines)
// ============================================================================

#[rstest]
#[case("package Test { feature wheelMass subsets mass; }", SpecializationKind::Subsets)]
#[case("package Test { feature currentMass redefines mass; }", SpecializationKind::Redefines)]
#[case("package Test { feature x :> base; }", SpecializationKind::Specializes)]
#[case("package Test { feature y :>> original; }", SpecializationKind::Redefines)]
fn test_feature_specialization_kinds(
    #[case] input: &str,
    #[case] expected_kind: SpecializationKind,
) {
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();

    match &members[0] {
        NamespaceMember::Package(pkg) => {
            let pkg_members: Vec<_> = pkg.members().collect();
            match &pkg_members[0] {
                NamespaceMember::Usage(usage) => {
                    let specs: Vec<_> = usage.specializations().collect();
                    assert!(!specs.is_empty(), "Should have specialization for: {}", input);
                    assert_eq!(
                        specs[0].kind(),
                        Some(expected_kind),
                        "Wrong specialization kind for: {}",
                        input
                    );
                }
                _ => panic!("Expected Usage for: {}", input),
            }
        }
        _ => panic!("Expected Package for: {}", input),
    }
}

// ============================================================================
// Feature Modifier Tests - derived
// ============================================================================

#[rstest]
#[case("package Test { derived feature x; }", true)]
#[case("package Test { feature x; }", false)]
fn test_derived_modifier(#[case] input: &str, #[case] expected_derived: bool) {
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();

    match &members[0] {
        NamespaceMember::Package(pkg) => {
            let pkg_members: Vec<_> = pkg.members().collect();
            match &pkg_members[0] {
                NamespaceMember::Usage(usage) => {
                    assert_eq!(
                        usage.is_derived(),
                        expected_derived,
                        "Derived mismatch for: {}",
                        input
                    );
                }
                _ => panic!("Expected Usage for: {}", input),
            }
        }
        _ => panic!("Expected Package for: {}", input),
    }
}

// ============================================================================
// Package Tests
// ============================================================================

#[rstest]
#[case("package MyPackage;", "MyPackage")]
#[case("package Test {}", "Test")]
#[case("package Nested { }", "Nested")]
fn test_package_parsing(#[case] input: &str, #[case] expected_name: &str) {
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();

    match &members[0] {
        NamespaceMember::Package(pkg) => {
            assert_eq!(
                pkg.name().and_then(|n| n.text()),
                Some(expected_name.to_string())
            );
        }
        _ => panic!("Expected Package for: {}", input),
    }
}

// ============================================================================
// Library Package Tests
// ============================================================================

#[rstest]
#[case("library package MyLib;", false, "MyLib")]
#[case("standard library package ScalarValues;", true, "ScalarValues")]
#[case("standard library package Base;", true, "Base")]
fn test_library_package(
    #[case] input: &str,
    #[case] expected_standard: bool,
    #[case] expected_name: &str,
) {
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();

    match &members[0] {
        NamespaceMember::LibraryPackage(lib) => {
            assert_eq!(
                lib.is_standard(),
                expected_standard,
                "Standard mismatch for: {}",
                input
            );
            assert_eq!(
                lib.name().and_then(|n| n.text()),
                Some(expected_name.to_string())
            );
        }
        _ => panic!("Expected LibraryPackage for: {}", input),
    }
}

// ============================================================================
// Import Tests
// ============================================================================

#[rstest]
#[case("import Base::*;", true, false)]
#[case("import all Library::**;", false, true)]
#[case("import MyPackage;", false, false)]
fn test_import_parsing(
    #[case] input: &str,
    #[case] expected_wildcard: bool,
    #[case] expected_recursive: bool,
) {
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();

    match &members[0] {
        NamespaceMember::Import(imp) => {
            assert_eq!(
                imp.is_wildcard(),
                expected_wildcard,
                "Wildcard mismatch for: {}",
                input
            );
            assert_eq!(
                imp.is_recursive(),
                expected_recursive,
                "Recursive mismatch for: {}",
                input
            );
        }
        _ => panic!("Expected Import for: {}", input),
    }
}

// ============================================================================
// Nested Definition Tests
// ============================================================================

#[rstest]
#[case("classifier Vehicle { feature mass : Real; }", "Vehicle", "mass")]
#[case("class Car { feature engine : Engine; }", "Car", "engine")]
#[case("struct Point { feature x : Real; }", "Point", "x")]
fn test_nested_feature_in_definition(
    #[case] input: &str,
    #[case] def_name: &str,
    #[case] feature_name: &str,
) {
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();

    match &members[0] {
        NamespaceMember::Definition(def) => {
            assert_eq!(
                def.name().and_then(|n| n.text()),
                Some(def_name.to_string())
            );

            let nested: Vec<_> = def.members().collect();
            assert!(!nested.is_empty(), "Should have nested members");

            match &nested[0] {
                NamespaceMember::Usage(usage) => {
                    assert_eq!(
                        usage.name().and_then(|n| n.text()),
                        Some(feature_name.to_string())
                    );
                }
                _ => panic!("Expected nested Usage"),
            }
        }
        _ => panic!("Expected Definition"),
    }
}

// ============================================================================
// Dependency Tests
// ============================================================================

#[rstest]
#[case("dependency Source to Target;")]
#[case("dependency MyDep from Source to Target;")]
#[case("dependency A, B to C, D;")]
fn test_dependency_parsing(#[case] input: &str) {
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();

    match &members[0] {
        NamespaceMember::Dependency(_dep) => {
            // Successfully parsed as Dependency
        }
        other => panic!("Expected Dependency, got {:?} for: {}", other, input),
    }
}

// ============================================================================
// Comment Tests
// ============================================================================

#[rstest]
#[case("package Test { comment /* This is a comment */ }")]
#[case("package Test { comment myComment /* text */ }")]
fn test_comment_parsing(#[case] input: &str) {
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();

    match &members[0] {
        NamespaceMember::Package(pkg) => {
            let pkg_members: Vec<_> = pkg.members().collect();
            match &pkg_members[0] {
                NamespaceMember::Comment(_) => {
                    // Successfully parsed as Comment
                }
                other => panic!("Expected Comment, got {:?}", other),
            }
        }
        _ => panic!("Expected Package"),
    }
}

// ============================================================================
// Round-Trip Parse Tests - Verify inputs parse successfully
// These test that various KerML constructs parse without errors
// ============================================================================

#[rstest]
// Basic types
#[case("type MyType;")]
#[case("abstract type MyType {}")]
#[case("type MyType ordered {}")]
// Classes
#[case("class MyClass;")]
#[case("class MyClass {}")]
#[case("abstract class MyClass;")]
#[case("class MyClass specializes Base {}")]
// Datatypes
#[case("datatype MyData;")]
#[case("datatype MyData {}")]
#[case("abstract datatype ScalarValue specializes DataValue;")]
// Structs
#[case("struct MyStruct;")]
#[case("struct MyStruct {}")]
#[case("abstract struct MyStruct specializes Base {}")]
// Associations
#[case("assoc MyAssoc;")]
#[case("assoc MyAssoc {}")]
#[case("abstract assoc Link specializes Anything {}")]
// Behaviors
#[case("behavior MyBehavior;")]
#[case("behavior MyBehavior {}")]
#[case("abstract behavior Performance specializes Occurrence {}")]
// Functions
#[case("function MyFunction;")]
#[case("function MyFunction {}")]
#[case("function sum { in a: Integer; return : Integer; }")]
// Predicates
#[case("predicate MyPredicate;")]
#[case("predicate MyPredicate {}")]
// Interactions
#[case("interaction MyInteraction;")]
#[case("interaction MyInteraction {}")]
// Metaclasses
#[case("metaclass MyMetaclass;")]
#[case("metaclass MyMetaclass {}")]
// Connectors
#[case("package Test { connector MyConnector; }")]
#[case("package Test { connector MyConnector {} }")]
// Bindings
#[case("package Test { binding MyBinding; }")]
#[case("package Test { binding MyBinding {} }")]
// Successions
#[case("package Test { succession MySuccession; }")]
#[case("package Test { succession MySuccession {} }")]
// Steps
#[case("package Test { step MyStep; }")]
#[case("package Test { step MyStep {} }")]
// Expressions
#[case("package Test { expr MyExpr; }")]
#[case("package Test { expr MyExpr {} }")]
// Features with modifiers
#[case("package Test { feature MyFeature; }")]
#[case("package Test { feature MyFeature {} }")]
#[case("package Test { abstract feature MyFeature; }")]
#[case("package Test { composite feature MyFeature; }")]
#[case("package Test { portion feature MyFeature; }")]
#[case("package Test { const feature MyFeature; }")]
#[case("package Test { derived feature MyFeature; }")]
#[case("package Test { end feature MyFeature; }")]
#[case("package Test { feature MyFeature ordered; }")]
#[case("package Test { feature MyFeature nonunique; }")]
#[case("package Test { feature MyFeature ordered nonunique; }")]
// Features with direction
#[case("function Test { in feature MyFeature; }")]
#[case("function Test { out feature MyFeature; }")]
#[case("function Test { inout feature MyFeature; }")]
// Imports
#[case("import MyPackage;")]
#[case("public import MyLib;")]
#[case("import all MyNamespace;")]
#[case("private import all Base;")]
#[case("import MyPackage::*;")]
#[case("import MyPackage::**;")]
// Dependencies
#[case("dependency Source to Target;")]
#[case("dependency MyDep from Source to Target;")]
// Namespaces
#[case("namespace MyNamespace;")]
#[case("namespace MyNamespace {}")]
// Packages
#[case("package MyPackage;")]
#[case("package MyPackage {}")]
// Library packages
#[case("library package LibPkg;")]
#[case("standard library package StdLib;")]
fn test_kerml_parses(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Complex Feature Tests
// ============================================================================

#[rstest]
#[case("package Test { feature elements[0..*] :>> Collection::elements {} }")]
#[case("package Test { feature myFeature[1] :> BaseFeature; }")]
#[case("package Test { feature items[*] : ItemType ordered; }")]
#[case("package Test { feature dimensions: Positive[0..*] ordered nonunique { } }")]
fn test_complex_features(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Function Parameter Tests
// ============================================================================

#[rstest]
#[case("function test { in x: Integer[1]; }")]
#[case("function test { out result: Boolean[1]; }")]
#[case("function test { inout value: Real[0..*]; }")]
#[case("function test { return : Integer[1]; }")]
#[case("function test { return result: Natural[1]; }")]
fn test_function_parameters(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Specialization Relationship Tests
// ============================================================================

#[rstest]
#[case("classifier A :> B;")]
#[case("classifier A specializes B;")]
#[case("package Test { feature x subsets y; }")]
#[case("package Test { feature x redefines y; }")]
#[case("package Test { feature x :>> y; }")]
#[case("package Test { feature x ::> y; }")]
fn test_specialization_relationships(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Multiple Members Tests
// ============================================================================

#[test]
fn test_multiple_definitions() {
    let input = r#"
        classifier A;
        classifier B;
        classifier C;
    "#;
    let file = assert_parses_with_members(input, 3);
    
    for member in file.members() {
        match member {
            NamespaceMember::Definition(_) => {}
            other => panic!("Expected Definition, got {:?}", other),
        }
    }
}

#[test]
fn test_package_with_multiple_members() {
    let input = r#"
        package Test {
            import Base::*;
            classifier Vehicle;
            feature engine : Engine;
        }
    "#;
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();
    assert_eq!(members.len(), 1); // One package
    
    match &members[0] {
        NamespaceMember::Package(pkg) => {
            let pkg_members: Vec<_> = pkg.members().collect();
            assert!(pkg_members.len() >= 2, "Package should have multiple members");
        }
        _ => panic!("Expected Package"),
    }
}

// ============================================================================
// Standard Library Pattern Tests
// ============================================================================

#[test]
fn test_standard_library_pattern() {
    let input = r#"standard library package ScalarValues {
        private import Base::DataValue;
        abstract datatype ScalarValue specializes DataValue;
        datatype Boolean specializes ScalarValue;
    }"#;
    
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();
    
    match &members[0] {
        NamespaceMember::LibraryPackage(lib) => {
            assert!(lib.is_standard());
            assert_eq!(lib.name().and_then(|n| n.text()), Some("ScalarValues".to_string()));
            
            let lib_members: Vec<_> = lib.members().collect();
            assert!(lib_members.len() >= 2, "Library should have members");
        }
        _ => panic!("Expected LibraryPackage"),
    }
}

// ============================================================================
// Classifier with Body Tests
// ============================================================================

#[rstest]
#[case(r#"classifier Vehicle {
    feature mass : Real;
    feature speed : Real;
}"#, 2)]
#[case(r#"class Car specializes Vehicle {
    feature engine : Engine;
}"#, 1)]
fn test_classifier_with_body(#[case] input: &str, #[case] expected_members: usize) {
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();
    
    match &members[0] {
        NamespaceMember::Definition(def) => {
            let nested: Vec<_> = def.members().collect();
            assert_eq!(
                nested.len(),
                expected_members,
                "Expected {} nested members",
                expected_members
            );
        }
        _ => panic!("Expected Definition"),
    }
}

// ============================================================================
// Connector Tests (from disabled file lines 3400+)
// ============================================================================

#[rstest]
#[case("package Test { connector x to y; }")]
#[case("package Test { connector from self to occ; }")]
#[case("package Test { connector myConn: Type from a to b; }")]
fn test_connector_patterns(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Binding Connector Tests
// ============================================================================

#[rstest]
#[case("package Test { binding a = b; }")]
#[case("package Test { binding x.y = z; }")]
fn test_binding_patterns(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Succession Tests
// ============================================================================

#[rstest]
#[case("package Test { succession a then b; }")]
#[case("package Test { first a then b; }")]
fn test_succession_patterns(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Flow Tests
// ============================================================================

#[rstest]
#[case("package Test { flow myFlow from a to b; }")]
#[case("package Test { flow a.y to b.x; }")]
fn test_flow_patterns(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Invariant Tests
// ============================================================================

#[rstest]
#[case("package Test { inv MyInvariant; }")]
#[case("package Test { inv not MyInvariant {} }")]
fn test_invariant_patterns(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Metadata Tests
// ============================================================================

#[rstest]
#[case("package Test { metadata MyType; }")]
#[case("package Test { metadata myMeta : MyType; }")]
#[case("package Test { metadata MyType about Foo; }")]
fn test_metadata_patterns(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Feature with Multiplicity Tests
// ============================================================================

#[rstest]
#[case("package Test { feature x[1]; }")]
#[case("package Test { feature x[0..1]; }")]
#[case("package Test { feature x[0..*]; }")]
#[case("package Test { feature x[*]; }")]
#[case("package Test { feature x[1..*]; }")]
fn test_feature_multiplicity(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Feature with Value Tests
// ============================================================================

#[rstest]
#[case("package Test { feature x = 42; }")]
#[case("package Test { feature x = true; }")]
#[case("package Test { feature x = null; }")]
#[case("package Test { feature rank: Natural[1] = size(dimensions); }")]
fn test_feature_with_value(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Disjoint Tests
// ============================================================================

#[rstest]
#[case("abstract class Occurrence specializes Anything disjoint from DataValue {}")]
#[case("package Test { disjoint a from b; }")]
fn test_disjoint_patterns(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Alias Tests
// ============================================================================

#[rstest]
#[case("package Test { alias MyAlias for Target; }")]
fn test_alias_patterns(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// End Feature Tests
// ============================================================================

#[rstest]
#[case("package Test { end feature x : MyType; }")]
#[case("package Test { end feature y : BaseType[1]; }")]
fn test_end_feature_patterns(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Conjugation Tests
// ============================================================================

#[rstest]
#[case("classifier A conjugates B;")]
#[case("classifier A ~ B;")]
fn test_conjugation_patterns(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Union/Intersection/Difference Tests
// ============================================================================

#[rstest]
#[case("type A unions B {}")]
#[case("type A intersects B {}")]
#[case("type A differences B {}")]
fn test_set_operation_patterns(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Feature Chaining Tests
// ============================================================================

#[rstest]
#[case("package Test { feature chain chains source.target; }")]
fn test_feature_chaining(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Inverse Feature Tests
// ============================================================================

#[rstest]
#[case("package Test { inverse B::g of A::f; }")]
fn test_inverse_feature(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Subset Member Tests
// ============================================================================

#[rstest]
#[case("package Test { subset a.b subsets c.d; }")]
fn test_subset_member(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Association Structure Tests
// ============================================================================

#[rstest]
#[case("assoc struct MyAssocStruct;")]
#[case("assoc struct MyAssocStruct {}")]
fn test_association_structure(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Consolidated Round-Trip Parse Tests
// Adapted from tests_parser_kerml_pest.rs.disabled consolidated tests
// ============================================================================

// --- Literals and Names ---
#[rstest]
#[case("package Test { feature x = 42; }")]
#[case("package Test { feature x = 3.14; }")]
#[case("package Test { feature x = 1.5e10; }")]
#[case("package Test { feature x = true; }")]
#[case("package Test { feature x = false; }")]
#[case("package Test { feature x = null; }")]
#[case("package Test { feature x = *; }")]
fn test_literal_values(#[case] input: &str) {
    assert_parses(input);
}

// --- Qualified Names ---
#[rstest]
#[case("classifier A :> Foo;")]
#[case("classifier A :> Foo::Bar;")]
#[case("classifier A :> Foo::Bar::Baz;")]
#[case("import Foo;")]
#[case("import Foo::Bar;")]
#[case("import Foo::Bar::Baz;")]
fn test_qualified_names(#[case] input: &str) {
    assert_parses(input);
}

// --- Feature Chain Expressions ---
#[rstest]
#[case("package Test { feature x = a.b; }")]
#[case("package Test { feature x = a.b.c; }")]
#[case("package Test { feature x = a.b.c.d; }")]
fn test_feature_chain_expressions(#[case] input: &str) {
    assert_parses(input);
}

// --- Index Expressions ---
#[rstest]
#[case("package Test { feature x = arr[0]; }")]
#[case("package Test { feature x = matrix[1][2]; }")]
fn test_index_expressions(#[case] input: &str) {
    assert_parses(input);
}

// --- Specialization Relationships ---
#[rstest]
#[case("classifier A :> BaseType;")]
#[case("classifier A specializes BaseClass;")]
#[case("classifier A :> Base1, Base2;")]
#[case("classifier A :> Base1, Base2, Base3;")]
fn test_specialization_syntax(#[case] input: &str) {
    assert_parses(input);
}

// --- Subsetting Relationships ---
#[rstest]
#[case("package Test { feature x :> BaseType; }")]
#[case("package Test { feature x subsets BaseClass; }")]
#[case("package Test { feature x :> Base::MyType; }")]
#[case("package Test { feature x :> Clock, Life; }")]
#[case("package Test { feature x :> Type1, Type2, Type3; }")]
fn test_subsetting_syntax(#[case] input: &str) {
    assert_parses(input);
}

// --- Redefinition Relationships ---
#[rstest]
#[case("package Test { feature x :>> BaseType; }")]
#[case("package Test { feature x redefines OldFeature; }")]
#[case("package Test { feature x :>> Base::Type; }")]
#[case("package Test { feature x :>> Collection::elements; }")]
#[case("package Test { feature x :>> Feature1, Feature2; }")]
fn test_redefinition_syntax(#[case] input: &str) {
    assert_parses(input);
}

// --- Reference Subsetting ---
#[rstest]
#[case("package Test { feature x ::> RefType; }")]
#[case("package Test { feature x references RefFeature; }")]
#[case("package Test { feature x ::> Ref::Feature; }")]
fn test_reference_subsetting_syntax(#[case] input: &str) {
    assert_parses(input);
}

// --- Cross Subsetting ---
#[rstest]
#[case("package Test { feature x => CrossedType; }")]
#[case("package Test { feature x crosses CrossedFeature; }")]
#[case("package Test { feature x => Cross::Type; }")]
fn test_cross_subsetting_syntax(#[case] input: &str) {
    assert_parses(input);
}

// --- Conjugation ---
#[rstest]
#[case("classifier A conjugates BaseType;")]
#[case("classifier A ~ ConjugateType;")]
fn test_conjugation_syntax(#[case] input: &str) {
    assert_parses(input);
}

// --- Set Operations ---
#[rstest]
#[case("type A unions Type1 {}")]
#[case("type A differences Type1 {}")]
#[case("type A intersects Type1 {}")]
#[case("type A intersects VectorValue, Array {}")]
fn test_set_operation_syntax(#[case] input: &str) {
    assert_parses(input);
}

// --- Feature Chaining ---
#[rstest]
#[case("package Test { feature x chains feature1; }")]
#[case("package Test { feature x chains source.target; }")]
#[case("package Test { feature x chains a.b.c; }")]
#[case("package Test { feature x chains parent.child; }")]
fn test_feature_chaining_syntax(#[case] input: &str) {
    assert_parses(input);
}

// --- Disjoint ---
#[rstest]
#[case("class A disjoint from B {}")]
#[case("package Test { disjoint Type1 from Type2; }")]
fn test_disjoint_syntax(#[case] input: &str) {
    assert_parses(input);
}

// --- Feature Inverting ---
#[rstest]
#[case("package Test { inverse feature1 of feature2; }")]
#[case("package Test { inverse B::g of A::f; }")]
fn test_feature_inverting_syntax(#[case] input: &str) {
    assert_parses(input);
}

// --- Type Featuring ---
#[rstest]
#[case("package Test { feature x featured by Type1; }")]
#[case("package Test { featuring feature1 by Type1; }")]
fn test_type_featuring_syntax(#[case] input: &str) {
    assert_parses(input);
}

// --- Feature Typing ---
#[rstest]
#[case("package Test { feature x : BaseType; }")]
#[case("package Test { feature x typed by TypeSpec; }")]
#[case("package Test { feature x : Complex; }")]
#[case("package Test { feature x : Boolean, String; }")]
#[case("package Test { feature x : Anything; }")]
#[case("package Test { feature x : String, Integer; }")]
fn test_feature_typing_syntax(#[case] input: &str) {
    assert_parses(input);
}

// --- Subclassification ---
#[rstest]
#[case("package Test { subclassifier SubClass :> BaseClass; }")]
#[case("package Test { subclassifier MyClass specializes ClassSpec; }")]
fn test_subclassification_syntax(#[case] input: &str) {
    assert_parses(input);
}

// --- Feature Value ---
#[rstest]
#[case("package Test { feature x = MyRef; }")]
#[case("package Test { feature x := MyRef; }")]
#[case("package Test { feature x default MyRef; }")]
fn test_feature_value_syntax(#[case] input: &str) {
    assert_parses(input);
}

// --- Import Variations ---
#[rstest]
#[case("import MyPackage;")]
#[case("public import MyLib;")]
#[case("private import MyLib;")]
#[case("protected import MyLib;")]
#[case("import all MyNamespace;")]
#[case("private import all Base;")]
#[case("import MyImport::*;")]
#[case("import MyImport::**;")]
#[case("import MyImport::*::**;")]
fn test_import_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Dependency Variations ---
#[rstest]
#[case("dependency Source to Target;")]
#[case("dependency MyDep from Source to Target;")]
#[case("dependency Source, Other to Target, Dest;")]
fn test_dependency_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Namespace Variations ---
#[rstest]
#[case("namespace MyNamespace;")]
#[case("namespace MyNamespace {}")]
fn test_namespace_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Package Variations ---
#[rstest]
#[case("package MyPackage;")]
#[case("package MyPackage {}")]
fn test_package_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Library Package Variations ---
#[rstest]
#[case("library package LibPkg;")]
#[case("standard library package StdLib;")]
#[case("library package MyLib {}")]
fn test_library_package_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Class Variations ---
#[rstest]
#[case("class MyClass;")]
#[case("class MyClass {}")]
#[case("abstract class MyClass;")]
#[case("class MyClass specializes Base {}")]
#[case("abstract class MyClass specializes Base, Other {}")]
#[case("class all MyClass specializes Base;")]
#[case("class MyClass[1] :> Base {}")]
fn test_class_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Datatype Variations ---
#[rstest]
#[case("datatype MyData;")]
#[case("datatype MyData {}")]
#[case("abstract datatype ScalarValue specializes DataValue;")]
#[case("datatype Boolean specializes ScalarValue;")]
#[case("datatype String specializes ScalarValue;")]
fn test_datatype_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Struct Variations ---
#[rstest]
#[case("struct MyStruct;")]
#[case("struct MyStruct {}")]
#[case("struct MyStruct[1] :> Parent {}")]
#[case("private struct MyStruct[0..1] specializes Base {}")]
#[case("abstract struct MyStruct specializes Base, Other {}")]
fn test_struct_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Association Variations ---
#[rstest]
#[case("assoc MyAssoc;")]
#[case("assoc MyAssoc {}")]
#[case("abstract assoc Link specializes Anything {}")]
#[case("assoc MyAssoc specializes Base {}")]
fn test_association_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Association Structure Variations ---
#[rstest]
#[case("assoc struct MyAssocStruct;")]
#[case("assoc struct MyAssocStruct {}")]
fn test_association_structure_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Behavior Variations ---
#[rstest]
#[case("behavior MyBehavior;")]
#[case("behavior MyBehavior {}")]
#[case("abstract behavior DecisionPerformance specializes Performance {}")]
#[case("behavior MyBehavior specializes Base, Other {}")]
fn test_behavior_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Function Variations ---
#[rstest]
#[case("function MyFunction;")]
#[case("function MyFunction {}")]
#[case("function '==' {}")]
#[case("function '!=' {}")]
#[case("function '+' {}")]
#[case("abstract function '-' {}")]
#[case("function sum { in a: Integer; return : Integer; }")]
fn test_function_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Predicate Variations ---
#[rstest]
#[case("predicate MyPredicate;")]
#[case("predicate MyPredicate {}")]
fn test_predicate_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Interaction Variations ---
#[rstest]
#[case("interaction MyInteraction;")]
#[case("interaction MyInteraction {}")]
fn test_interaction_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Metaclass Variations ---
#[rstest]
#[case("metaclass MyMetaclass;")]
#[case("metaclass MyMetaclass {}")]
fn test_metaclass_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Connector Variations ---
#[rstest]
#[case("package Test { connector MyConnector; }")]
#[case("package Test { connector MyConnector {} }")]
#[case("package Test { connector x to y; }")]
#[case("package Test { connector from self to occ; }")]
#[case("package Test { connector a ::> a.x to b; }")]
#[case("package Test { connector all from x to y; }")]
#[case("package Test { connector myConn: Type from a to b; }")]
fn test_connector_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Binding Connector Variations ---
#[rstest]
#[case("package Test { binding MyBinding; }")]
#[case("package Test { binding MyBinding {} }")]
#[case("package Test { binding a = b; }")]
#[case("package Test { binding x.y = z; }")]
fn test_binding_connector_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Succession Variations ---
#[rstest]
#[case("package Test { succession MySuccession; }")]
#[case("package Test { succession MySuccession {} }")]
#[case("package Test { succession a then b; }")]
#[case("package Test { first a then b; }")]
fn test_succession_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Step Variations ---
#[rstest]
#[case("package Test { step MyStep; }")]
#[case("package Test { step MyStep {} }")]
fn test_step_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Expression Variations ---
#[rstest]
#[case("package Test { expr MyExpr; }")]
#[case("package Test { expr MyExpr {} }")]
fn test_expression_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Invariant Variations ---
#[rstest]
#[case("package Test { inv MyInvariant; }")]
#[case("package Test { inv not MyInvariant {} }")]
fn test_invariant_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Feature Basic Variations ---
#[rstest]
#[case("package Test { feature MyFeature; }")]
#[case("package Test { feature MyFeature {} }")]
fn test_feature_basic_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Feature with Direction Variations ---
#[rstest]
#[case("function Test { in feature MyFeature; }")]
#[case("function Test { out feature MyFeature; }")]
#[case("function Test { inout feature MyFeature; }")]
fn test_feature_direction_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Feature with Composition Variations ---
#[rstest]
#[case("package Test { abstract feature MyFeature; }")]
#[case("package Test { composite feature MyFeature; }")]
#[case("package Test { portion feature MyFeature; }")]
fn test_feature_composition_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Feature with Property Variations ---
#[rstest]
#[case("package Test { const feature MyFeature; }")]
#[case("package Test { derived feature MyFeature; }")]
#[case("package Test { end feature MyFeature; }")]
fn test_feature_property_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Feature with Multiplicity Properties ---
#[rstest]
#[case("package Test { feature MyFeature ordered; }")]
#[case("package Test { feature MyFeature nonunique; }")]
#[case("package Test { feature MyFeature ordered nonunique; }")]
fn test_feature_multiplicity_properties(#[case] input: &str) {
    assert_parses(input);
}

// --- Feature Combined Modifiers ---
#[rstest]
#[case("function Test { in abstract const feature MyFeature ordered; }")]
#[case("function Test { out composite derived feature MyFeature nonunique; }")]
#[case("function Test { inout portion end feature MyFeature ordered nonunique; }")]
fn test_feature_combined_modifiers(#[case] input: &str) {
    assert_parses(input);
}

// --- Feature with Multiplicity and Relationships ---
#[rstest]
#[case("package Test { feature elements[0..*] :>> Collection::elements {} }")]
#[case("package Test { feature myFeature[1] :> BaseFeature; }")]
#[case("package Test { feature items[*] : ItemType ordered; }")]
fn test_feature_multiplicity_relationships(#[case] input: &str) {
    assert_parses(input);
}

// --- Comment Variations ---
#[rstest]
#[case("package Test { comment /* simple comment */ }")]
#[case("package Test { comment myComment /* comment text */ }")]
#[case("package Test { comment about Foo /* about Foo */ }")]
#[case("package Test { comment about Bar, Baz /* about multiple */ }")]
fn test_comment_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Documentation Variations ---
#[rstest]
#[case("package Test { doc /* documentation */ }")]
#[case("package Test { doc MyDoc /* doc text */ }")]
fn test_documentation_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Metadata Feature Variations ---
#[rstest]
#[case("package Test { metadata MyType; }")]
#[case("package Test { metadata myMeta : MyType; }")]
#[case("package Test { metadata MyType about Foo; }")]
#[case("package Test { metadata myMeta : MyType about Foo, Bar; }")]
fn test_metadata_feature_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Flow Variations ---
#[rstest]
#[case("package Test { flow myFlow; }")]
#[case("package Test { flow myFlow from a to b; }")]
#[case("package Test { flow a.y to b.x; }")]
fn test_flow_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Succession Flow Variations ---
#[rstest]
#[case("package Test { succession flow; }")]
#[case("package Test { succession flow myFlow; }")]
fn test_succession_flow_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Parameter Membership Variations ---
#[rstest]
#[case("function Test { in x: Anything[0..1]; }")]
#[case("function Test { in y: Boolean[1]; }")]
#[case("function Test { out result: Natural[1]; }")]
#[case("function Test { inout value: Complex[0..*]; }")]
#[case("function Test { in x: Anything[0..*] nonunique; }")]
#[case("function Test { in x: Anything[0..*] ordered; }")]
fn test_parameter_membership_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Return Parameter Membership Variations ---
#[rstest]
#[case("function Test { return : Boolean[1]; }")]
#[case("function Test { return result: Natural[1]; }")]
#[case("function Test { return : Complex[1] = x + y; }")]
fn test_return_parameter_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Function with Parameters ---
#[rstest]
#[case("function '==' { in x: Anything[0..1]; in y: Anything[0..1]; return : Boolean[1]; }")]
#[case("function add { in a: Natural[1]; in b: Natural[1]; return : Natural[1]; }")]
fn test_function_with_parameters(#[case] input: &str) {
    assert_parses(input);
}

// --- Quoted Identifiers ---
#[rstest]
#[case("function '==' {}")]
#[case("function '!=' {}")]
#[case("function '+' {}")]
#[case("function '-' {}")]
#[case("function '*' {}")]
#[case("function '/' {}")]
#[case("function '<' {}")]
#[case("function '>' {}")]
#[case("function '<=' {}")]
#[case("function '>=' {}")]
fn test_quoted_identifiers(#[case] input: &str) {
    assert_parses(input);
}

// --- Qualified Reference with Quotes ---
#[rstest]
#[case("function 'not' specializes ScalarFunctions::'not' {}")]
#[case("function 'xor' specializes Base::'xor' {}")]
fn test_qualified_reference_with_quotes(#[case] input: &str) {
    assert_parses(input);
}

// --- Binary Expressions ---
#[rstest]
#[case("package Test { feature r = x == y; }")]
#[case("package Test { feature r = x != y; }")]
#[case("package Test { feature r = x === y; }")]
#[case("package Test { feature r = x < y; }")]
#[case("package Test { feature r = x <= y; }")]
#[case("package Test { feature r = x > y; }")]
#[case("package Test { feature r = x >= y; }")]
#[case("package Test { feature r = x + y; }")]
#[case("package Test { feature r = x - y; }")]
#[case("package Test { feature r = x * y; }")]
#[case("package Test { feature r = x / y; }")]
#[case("package Test { feature r = x and y; }")]
#[case("package Test { feature r = x or y; }")]
#[case("package Test { feature r = x xor y; }")]
#[case("package Test { feature r = a == b and c == d; }")]
fn test_binary_expressions(#[case] input: &str) {
    assert_parses(input);
}

// --- Null Coalescing ---
#[rstest]
#[case("package Test { feature r = x ?? 0; }")]
fn test_null_coalescing(#[case] input: &str) {
    assert_parses(input);
}

// --- Parameter with Default ---
#[rstest]
#[case("function Test { in x: Integer[1] default 0; }")]
#[case("function Test { in endIndex: Positive[1] default startIndex; }")]
fn test_parameter_with_default(#[case] input: &str) {
    assert_parses(input);
}

// --- Short Name (Identification) ---
#[rstest]
#[case("classifier <short> regular;")]
#[case("classifier <shortName> MyClass;")]
#[case("package <pkg> MyPackage {}")]
fn test_short_name_identification(#[case] input: &str) {
    assert_parses(input);
}

// --- Classifier with All ---
#[rstest]
#[case("classifier all MyClassifier {}")]
#[case("type all x specializes A;")]
#[case("classifier all C :> Base {}")]
fn test_classifier_with_all(#[case] input: &str) {
    assert_parses(input);
}

// --- End Feature Variations ---
#[rstest]
#[case("package Test { end feature x : MyType; }")]
#[case("package Test { end feature y : BaseType[1]; }")]
#[case("package Test { end [1] feature transferSource ::> source; }")]
fn test_end_feature_variations(#[case] input: &str) {
    assert_parses(input);
}

// --- Feature with Prefix Metadata ---
#[rstest]
#[case("package Test { #Security feature z; }")]
fn test_feature_prefix_metadata(#[case] input: &str) {
    assert_parses(input);
}

// --- Invocation Expressions ---
#[rstest]
#[case("package Test { feature r = size(dimensions); }")]
#[case("package Test { feature r = foo(); }")]
#[case("package Test { feature r = max(a, b); }")]
#[case("package Test { feature r = calculate(x, y, z); }")]
#[case("package Test { feature r = rect(0.0, 1.0); }")]
#[case("package Test { feature r = polar(1.0, 3.14); }")]
#[case("package Test { feature r = sqrt(2.0); }")]
fn test_invocation_expressions(#[case] input: &str) {
    assert_parses(input);
}

// --- Conditional Expressions ---
#[rstest]
#[case("package Test { feature r = if true ? 1 else 0; }")]
#[case("package Test { feature r = if x > 5 ? yes else no; }")]
fn test_conditional_expressions(#[case] input: &str) {
    assert_parses(input);
}

// --- Collection Operators ---
#[rstest]
#[case("package Test { feature r = col->size; }")]
fn test_collection_operators(#[case] input: &str) {
    assert_parses(input);
}

// --- Typing and Redefinition Combined ---
#[rstest]
#[case("package Test { feature currentMass : Real redefines mass; }")]
#[case("package Test { feature x : Type :>> original; }")]
fn test_typing_and_redefinition(#[case] input: &str) {
    assert_parses(input);
}

// --- Abstract Flow ---
#[rstest]
#[case("package Test { abstract flow flowTransfers: FlowTransfer[0..*] nonunique subsets transfers {} }")]
fn test_abstract_flow(#[case] input: &str) {
    assert_parses(input);
}

// --- Classification Operators ---
#[rstest]
#[case("package Test { feature r = x hastype T; }")]
#[case("package Test { feature r = x istype T; }")]
#[case("package Test { feature r = x @ T; }")]
fn test_classification_operators(#[case] input: &str) {
    assert_parses(input);
}

// --- Multiple Subsetting Targets ---
#[rstest]
#[case("package Test { abstract step enactedPerformances: Performance[0..*] subsets performances, timeOccurrences {} }")]
fn test_multiple_subsetting_targets(#[case] input: &str) {
    assert_parses(input);
}

// --- Comment with Multiple About ---
#[rstest]
#[case("package Test { comment about Surface, Curve, Point /* body */ }")]
fn test_comment_multiple_about(#[case] input: &str) {
    assert_parses(input);
}

// --- Implies Operator ---
#[rstest]
#[case("package Test { feature r = a implies b; }")]
fn test_implies_operator(#[case] input: &str) {
    assert_parses(input);
}

// --- Feature with Var Modifier ---
#[rstest]
#[case("package Test { derived var feature annotatedElement : Element[1..*] ordered redefines annotatedElement; }")]
fn test_feature_var_modifier(#[case] input: &str) {
    assert_parses(input);
}

// --- Shorthand Feature with Redefines and Default ---
#[rstest]
#[case("package Test { :>> dimension = size(components); }")]
fn test_shorthand_feature_redefines_default(#[case] input: &str) {
    assert_parses(input);
}

// --- Binding with Feature Chain ---
#[rstest]
#[case("package Test { binding accept.receiver = triggerTarget; }")]
fn test_binding_feature_chain(#[case] input: &str) {
    assert_parses(input);
}

// --- Connector with From/To Endpoints ---
#[rstest]
#[case("package Test { connector :HappensDuring from [1] shorter references this to [1] longer references that; }")]
fn test_connector_from_to_endpoints(#[case] input: &str) {
    assert_parses(input);
}

// --- Locale Documentation ---
#[rstest]
#[case("package Test { locale \"en_US\" /* localized comment */ }")]
fn test_locale_documentation(#[case] input: &str) {
    assert_parses(input);
}

// --- Root Namespace Reference ---
#[rstest]
#[case("class E :> $::Objects::Object;")]
fn test_root_namespace_reference(#[case] input: &str) {
    assert_parses(input);
}
