//! SysML AST layer tests for Rowan parser.
//!
//! These tests verify that the typed AST wrappers correctly extract
//! semantic information from the untyped Rowan CST for SysML syntax.
//!
//! Adapted from tests_parser_sysml_pest.rs.disabled
//!
//! Run with: `cargo test --test tests_parser_sysml_ast`

use rstest::rstest;
use syster::parser::ast::{
    AstNode, DefinitionKind, Direction, NamespaceMember, SourceFile, SpecializationKind,
    UsageKind,
};
use syster::parser::parse;

// ============================================================================
// Test Helpers - Transform arrange/act for Rowan parser
// ============================================================================

/// Helper: Parse SysML input and return SourceFile AST
fn parse_source(input: &str) -> SourceFile {
    let parsed = parse(input);
    SourceFile::cast(parsed.syntax()).expect("Failed to cast to SourceFile")
}

/// Helper: Assert that SysML input parses without fatal errors
fn assert_parses(input: &str) -> syster::parser::Parse {
    let parsed = parse(input);
    assert!(
        !parsed.syntax().text().is_empty(),
        "Parse produced empty tree for: {}",
        input
    );
    parsed
}

/// Helper: Assert SysML parses and produces expected number of top-level members
fn assert_parses_with_members(input: &str, expected_count: usize) -> SourceFile {
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();
    assert_eq!(
        members.len(),
        expected_count,
        "Expected {} members for input: {}",
        expected_count,
        input
    );
    file
}

/// Helper: Assert a definition parses with expected kind and name
fn assert_definition(input: &str, expected_kind: DefinitionKind, expected_name: &str) {
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();
    assert!(!members.is_empty(), "No members parsed for: {}", input);

    match &members[0] {
        NamespaceMember::Definition(def) => {
            assert_eq!(
                def.definition_kind(),
                Some(expected_kind),
                "Wrong definition kind for: {}",
                input
            );
            assert_eq!(
                def.name().and_then(|n| n.text()),
                Some(expected_name.to_string()),
                "Wrong name for: {}",
                input
            );
        }
        other => panic!("Expected Definition, got {:?} for: {}", other, input),
    }
}

/// Helper: Assert a usage parses with expected kind and name
fn assert_usage(input: &str, expected_kind: UsageKind, expected_name: &str) {
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();

    match &members[0] {
        NamespaceMember::Package(pkg) => {
            let pkg_members: Vec<_> = pkg.members().collect();
            match &pkg_members[0] {
                NamespaceMember::Usage(usage) => {
                    assert_eq!(
                        usage.usage_kind(),
                        Some(expected_kind),
                        "Wrong usage kind for: {}",
                        input
                    );
                    assert_eq!(
                        usage.name().and_then(|n| n.text()),
                        Some(expected_name.to_string()),
                        "Wrong usage name for: {}",
                        input
                    );
                }
                other => panic!("Expected Usage, got {:?} for: {}", other, input),
            }
        }
        NamespaceMember::Usage(usage) => {
            assert_eq!(
                usage.usage_kind(),
                Some(expected_kind),
                "Wrong usage kind for: {}",
                input
            );
            assert_eq!(
                usage.name().and_then(|n| n.text()),
                Some(expected_name.to_string()),
                "Wrong usage name for: {}",
                input
            );
        }
        other => panic!("Expected Package or Usage, got {:?} for: {}", other, input),
    }
}

// ============================================================================
// Definition Kind Tests - SysML-specific definitions
// ============================================================================

#[rstest]
#[case("part def MyPart;", DefinitionKind::Part, "MyPart")]
#[case("abstract part def Vehicle;", DefinitionKind::Part, "Vehicle")]
#[case("attribute def MyAttr;", DefinitionKind::Attribute, "MyAttr")]
#[case("port def MyPort;", DefinitionKind::Port, "MyPort")]
#[case("item def MyItem;", DefinitionKind::Item, "MyItem")]
#[case("action def MyAction;", DefinitionKind::Action, "MyAction")]
#[case("state def MyState;", DefinitionKind::State, "MyState")]
#[case("constraint def MyConstraint;", DefinitionKind::Constraint, "MyConstraint")]
#[case("requirement def MyReq;", DefinitionKind::Requirement, "MyReq")]
#[case("case def MyCase;", DefinitionKind::Case, "MyCase")]
#[case("calc def MyCalc;", DefinitionKind::Calc, "MyCalc")]
#[case("connection def MyConn;", DefinitionKind::Connection, "MyConn")]
#[case("interface def MyInterface;", DefinitionKind::Interface, "MyInterface")]
#[case("allocation def MyAlloc;", DefinitionKind::Allocation, "MyAlloc")]
#[case("flow def MyFlow;", DefinitionKind::Flow, "MyFlow")]
#[case("view def MyView;", DefinitionKind::View, "MyView")]
#[case("viewpoint def MyViewpoint;", DefinitionKind::Viewpoint, "MyViewpoint")]
#[case("rendering def MyRendering;", DefinitionKind::Rendering, "MyRendering")]
#[case("metadata def MyMetadata;", DefinitionKind::Metadata, "MyMetadata")]
#[case("occurrence def MyOccurrence;", DefinitionKind::Occurrence, "MyOccurrence")]
#[case("enum def MyEnum;", DefinitionKind::Enum, "MyEnum")]
#[case("analysis def MyAnalysis;", DefinitionKind::Analysis, "MyAnalysis")]
#[case("verification def MyVerification;", DefinitionKind::Verification, "MyVerification")]
#[case("use case def MyUseCase;", DefinitionKind::UseCase, "MyUseCase")]
#[case("concern def MyConcern;", DefinitionKind::Concern, "MyConcern")]
fn test_definition_kinds(
    #[case] input: &str,
    #[case] expected_kind: DefinitionKind,
    #[case] expected_name: &str,
) {
    assert_definition(input, expected_kind, expected_name);
}

// ============================================================================
// Usage Kind Tests - SysML-specific usages
// ============================================================================

#[rstest]
#[case("package Test { part myPart; }", UsageKind::Part, "myPart")]
#[case("package Test { attribute myAttr; }", UsageKind::Attribute, "myAttr")]
#[case("package Test { port myPort; }", UsageKind::Port, "myPort")]
#[case("package Test { item myItem; }", UsageKind::Item, "myItem")]
#[case("package Test { action myAction; }", UsageKind::Action, "myAction")]
#[case("package Test { state myState; }", UsageKind::State, "myState")]
#[case("package Test { constraint myConstraint; }", UsageKind::Constraint, "myConstraint")]
#[case("package Test { requirement myReq; }", UsageKind::Requirement, "myReq")]
#[case("package Test { case myCase; }", UsageKind::Case, "myCase")]
#[case("package Test { calc myCalc; }", UsageKind::Calc, "myCalc")]
#[case("package Test { connection myConn; }", UsageKind::Connection, "myConn")]
#[case("package Test { interface myInterface; }", UsageKind::Interface, "myInterface")]
#[case("package Test { allocation myAlloc; }", UsageKind::Allocation, "myAlloc")]
#[case("package Test { flow myFlow; }", UsageKind::Flow, "myFlow")]
#[case("package Test { view myView; }", UsageKind::View, "myView")]
#[case("package Test { viewpoint myViewpoint; }", UsageKind::Viewpoint, "myViewpoint")]
#[case("package Test { rendering myRendering; }", UsageKind::Rendering, "myRendering")]
#[case("package Test { occurrence myOccurrence; }", UsageKind::Occurrence, "myOccurrence")]
#[case("package Test { concern myConcern; }", UsageKind::Concern, "myConcern")]
#[case("package Test { ref myRef; }", UsageKind::Ref, "myRef")]
fn test_usage_kinds(
    #[case] input: &str,
    #[case] expected_kind: UsageKind,
    #[case] expected_name: &str,
) {
    assert_usage(input, expected_kind, expected_name);
}

// ============================================================================
// Abstract Modifier Tests
// ============================================================================

#[rstest]
#[case("abstract part def Vehicle;", true)]
#[case("part def Vehicle;", false)]
#[case("abstract action def MyAction;", true)]
#[case("action def MyAction;", false)]
fn test_abstract_modifier(#[case] input: &str, #[case] expected_abstract: bool) {
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();

    match &members[0] {
        NamespaceMember::Definition(def) => {
            assert_eq!(
                def.is_abstract(),
                expected_abstract,
                "Abstract mismatch for: {}",
                input
            );
        }
        _ => panic!("Expected Definition for: {}", input),
    }
}

// ============================================================================
// Variation Modifier Tests
// ============================================================================

#[rstest]
#[case("variation part def VehicleChoices;", true)]
#[case("part def Vehicle;", false)]
fn test_variation_modifier(#[case] input: &str, #[case] expected_variation: bool) {
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();

    match &members[0] {
        NamespaceMember::Definition(def) => {
            assert_eq!(
                def.is_variation(),
                expected_variation,
                "Variation mismatch for: {}",
                input
            );
        }
        _ => panic!("Expected Definition for: {}", input),
    }
}

// ============================================================================
// Usage Direction Tests
// ============================================================================

#[rstest]
#[case("action def Test { in item x; }", Direction::In)]
#[case("action def Test { out item x; }", Direction::Out)]
#[case("action def Test { inout item x; }", Direction::InOut)]
fn test_usage_direction(#[case] input: &str, #[case] expected_dir: Direction) {
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();

    match &members[0] {
        NamespaceMember::Definition(def) => {
            let nested: Vec<_> = def.members().collect();
            match &nested[0] {
                NamespaceMember::Usage(usage) => {
                    assert_eq!(
                        usage.direction(),
                        Some(expected_dir),
                        "Direction mismatch for: {}",
                        input
                    );
                }
                _ => panic!("Expected Usage for: {}", input),
            }
        }
        _ => panic!("Expected Definition for: {}", input),
    }
}

// ============================================================================
// Usage Modifier Tests - ref, readonly, derived
// ============================================================================

#[rstest]
#[case("package Test { ref part myPart; }", true)]
#[case("package Test { part myPart; }", false)]
fn test_ref_modifier(#[case] input: &str, #[case] expected_ref: bool) {
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();

    match &members[0] {
        NamespaceMember::Package(pkg) => {
            let pkg_members: Vec<_> = pkg.members().collect();
            match &pkg_members[0] {
                NamespaceMember::Usage(usage) => {
                    assert_eq!(
                        usage.is_ref(),
                        expected_ref,
                        "Ref mismatch for: {}",
                        input
                    );
                }
                _ => panic!("Expected Usage for: {}", input),
            }
        }
        _ => panic!("Expected Package for: {}", input),
    }
}

#[rstest]
#[case("package Test { readonly part myPart; }", true)]
#[case("package Test { part myPart; }", false)]
fn test_readonly_modifier(#[case] input: &str, #[case] expected_readonly: bool) {
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();

    match &members[0] {
        NamespaceMember::Package(pkg) => {
            let pkg_members: Vec<_> = pkg.members().collect();
            match &pkg_members[0] {
                NamespaceMember::Usage(usage) => {
                    assert_eq!(
                        usage.is_readonly(),
                        expected_readonly,
                        "Readonly mismatch for: {}",
                        input
                    );
                }
                _ => panic!("Expected Usage for: {}", input),
            }
        }
        _ => panic!("Expected Package for: {}", input),
    }
}

#[rstest]
#[case("package Test { derived attribute x; }", true)]
#[case("package Test { attribute x; }", false)]
fn test_derived_modifier(#[case] input: &str, #[case] expected_derived: bool) {
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();

    match &members[0] {
        NamespaceMember::Package(pkg) => {
            let pkg_members: Vec<_> = pkg.members().collect();
            match &pkg_members[0] {
                NamespaceMember::Usage(usage) => {
                    assert_eq!(
                        usage.is_derived(),
                        expected_derived,
                        "Derived mismatch for: {}",
                        input
                    );
                }
                _ => panic!("Expected Usage for: {}", input),
            }
        }
        _ => panic!("Expected Package for: {}", input),
    }
}

// ============================================================================
// Package Tests
// ============================================================================

#[rstest]
#[case("package MyPackage;", "MyPackage")]
#[case("package Test {}", "Test")]
fn test_package_parsing(#[case] input: &str, #[case] expected_name: &str) {
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();

    match &members[0] {
        NamespaceMember::Package(pkg) => {
            assert_eq!(
                pkg.name().and_then(|n| n.text()),
                Some(expected_name.to_string())
            );
        }
        _ => panic!("Expected Package for: {}", input),
    }
}

// ============================================================================
// Library Package Tests
// ============================================================================

#[rstest]
#[case("library package MyLib;", false, "MyLib")]
#[case("standard library package ISQ;", true, "ISQ")]
fn test_library_package(
    #[case] input: &str,
    #[case] expected_standard: bool,
    #[case] expected_name: &str,
) {
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();

    match &members[0] {
        NamespaceMember::LibraryPackage(lib) => {
            assert_eq!(
                lib.is_standard(),
                expected_standard,
                "Standard mismatch for: {}",
                input
            );
            assert_eq!(
                lib.name().and_then(|n| n.text()),
                Some(expected_name.to_string())
            );
        }
        _ => panic!("Expected LibraryPackage for: {}", input),
    }
}

// ============================================================================
// Import Tests
// ============================================================================

#[rstest]
#[case("import ISQ::*;", true, false)]
#[case("import all Library::**;", false, true)]
#[case("import MyPackage;", false, false)]
fn test_import_parsing(
    #[case] input: &str,
    #[case] expected_wildcard: bool,
    #[case] expected_recursive: bool,
) {
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();

    match &members[0] {
        NamespaceMember::Import(imp) => {
            assert_eq!(
                imp.is_wildcard(),
                expected_wildcard,
                "Wildcard mismatch for: {}",
                input
            );
            assert_eq!(
                imp.is_recursive(),
                expected_recursive,
                "Recursive mismatch for: {}",
                input
            );
        }
        _ => panic!("Expected Import for: {}", input),
    }
}

// ============================================================================
// Specialization Tests
// ============================================================================

#[rstest]
#[case("part def Car :> Vehicle;", SpecializationKind::Specializes)]
#[case("part def Car specializes Vehicle;", SpecializationKind::Specializes)]
fn test_definition_specialization(#[case] input: &str, #[case] expected_kind: SpecializationKind) {
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();

    match &members[0] {
        NamespaceMember::Definition(def) => {
            let specs: Vec<_> = def.specializations().collect();
            assert!(!specs.is_empty(), "Should have specialization for: {}", input);
            assert_eq!(
                specs[0].kind(),
                Some(expected_kind),
                "Wrong specialization kind for: {}",
                input
            );
        }
        _ => panic!("Expected Definition for: {}", input),
    }
}

// ============================================================================
// Nested Members Tests
// ============================================================================

#[rstest]
#[case("part def Vehicle { part engine; }", "Vehicle", "engine")]
#[case("part def Car { attribute speed : Real; }", "Car", "speed")]
fn test_nested_usage_in_definition(
    #[case] input: &str,
    #[case] def_name: &str,
    #[case] usage_name: &str,
) {
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();

    match &members[0] {
        NamespaceMember::Definition(def) => {
            assert_eq!(
                def.name().and_then(|n| n.text()),
                Some(def_name.to_string())
            );

            let nested: Vec<_> = def.members().collect();
            assert!(!nested.is_empty(), "Should have nested members");

            match &nested[0] {
                NamespaceMember::Usage(usage) => {
                    assert_eq!(
                        usage.name().and_then(|n| n.text()),
                        Some(usage_name.to_string())
                    );
                }
                _ => panic!("Expected nested Usage"),
            }
        }
        _ => panic!("Expected Definition"),
    }
}

// ============================================================================
// Round-Trip Parse Tests - Basic SysML Constructs
// ============================================================================

#[rstest]
// Packages
#[case("package MyPackage;")]
#[case("package MyPackage {}")]
#[case("library package MyLibrary;")]
#[case("standard library package MyLibrary;")]
#[case("package Pkg1; package Pkg2;")]
// Part definitions
#[case("part def MyPart;")]
#[case("part def MyPart {}")]
#[case("abstract part def MyPart;")]
#[case("variation part def MyPart;")]
#[case("part def MyPart :> Base;")]
#[case("part def MyPart :> Base {}")]
// Attribute definitions
#[case("attribute def MyAttr;")]
#[case("attribute def MyAttr {}")]
// Port definitions
#[case("port def MyPort;")]
#[case("port def MyPort {}")]
#[case("port def ~MyConjugatedPort;")]
// Item definitions
#[case("item def MyItem;")]
#[case("item def MyItem {}")]
// Action definitions
#[case("action def MyAction;")]
#[case("action def MyAction {}")]
// State definitions
#[case("state def MyState;")]
#[case("state def MyState {}")]
// Constraint definitions
#[case("constraint def MyConstraint;")]
#[case("constraint def MyConstraint {}")]
// Requirement definitions
#[case("requirement def MyReq;")]
#[case("requirement def MyReq {}")]
// Case definitions
#[case("case def MyCase;")]
#[case("case def MyCase {}")]
// Calc definitions
#[case("calc def MyCalc;")]
#[case("calc def MyCalc {}")]
// Connection definitions
#[case("connection def MyConn;")]
#[case("connection def MyConn {}")]
// Interface definitions
#[case("interface def MyInterface;")]
#[case("interface def MyInterface {}")]
// Allocation definitions
#[case("allocation def MyAlloc;")]
#[case("allocation def MyAlloc {}")]
// Flow definitions
#[case("flow def MyFlow;")]
#[case("flow def MyFlow {}")]
// View definitions
#[case("view def MyView;")]
#[case("view def MyView {}")]
// Viewpoint definitions
#[case("viewpoint def MyViewpoint;")]
#[case("viewpoint def MyViewpoint {}")]
// Rendering definitions
#[case("rendering def MyRendering;")]
#[case("rendering def MyRendering {}")]
// Metadata definitions
#[case("metadata def MyMetadata;")]
#[case("abstract metadata def MyMetadata;")]
// Occurrence definitions
#[case("occurrence def MyOccurrence;")]
#[case("occurrence def MyOccurrence {}")]
// Enum definitions
#[case("enum def MyEnum;")]
#[case("enum def MyEnum {}")]
// Analysis definitions
#[case("analysis def MyAnalysis;")]
#[case("analysis def MyAnalysis {}")]
// Verification definitions
#[case("verification def MyVerification;")]
#[case("verification def MyVerification {}")]
// Use case definitions
#[case("use case def MyUseCase;")]
#[case("use case def MyUseCase {}")]
// Concern definitions
#[case("concern def MyConcern;")]
#[case("concern def MyConcern {}")]
// Individual definitions
#[case("individual def MyIndividual;")]
#[case("individual def MyIndividual {}")]
fn test_sysml_definitions_parse(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Round-Trip Parse Tests - SysML Usages
// ============================================================================

#[rstest]
// Part usages
#[case("package Test { part myPart; }")]
#[case("package Test { part myPart {} }")]
#[case("package Test { ref part myPart; }")]
#[case("package Test { abstract part myPart; }")]
// Attribute usages
#[case("package Test { attribute myAttr; }")]
#[case("package Test { attribute myAttr : Real; }")]
#[case("package Test { derived attribute myAttr; }")]
// Port usages
#[case("package Test { port myPort; }")]
#[case("package Test { port myPort : ~PortType; }")]
// Item usages
#[case("package Test { item myItem; }")]
#[case("package Test { end item myItem; }")]
// Action usages
#[case("package Test { action myAction; }")]
#[case("package Test { action myAction {} }")]
// State usages
#[case("package Test { state myState; }")]
#[case("package Test { ref state myState; }")]
// Constraint usages
#[case("package Test { constraint myConstraint; }")]
#[case("package Test { assert constraint {} }")]
// Requirement usages
#[case("package Test { requirement myReq; }")]
#[case("package Test { satisfy requirement; }")]
// Case usages
#[case("package Test { case myCase; }")]
// Calc usages
#[case("package Test { calc myCalc; }")]
// Connection usages
#[case("package Test { connection myConn; }")]
#[case("package Test { connect a to b; }")]
// Interface usages
#[case("package Test { interface myInterface; }")]
// Allocation usages
#[case("package Test { allocation myAlloc; }")]
#[case("package Test { allocate a to b; }")]
// Flow usages
#[case("package Test { flow myFlow; }")]
#[case("package Test { flow myFlow from a to b; }")]
// View usages
#[case("package Test { view myView; }")]
// Viewpoint usages
#[case("package Test { viewpoint myViewpoint; }")]
// Rendering usages
#[case("package Test { rendering myRendering; }")]
#[case("package Test { render myRendering; }")]
// Occurrence usages
#[case("package Test { occurrence myOccurrence; }")]
// Concern usages
#[case("package Test { concern myConcern; }")]
// Reference usages
#[case("package Test { ref myRef; }")]
#[case("package Test { ref myRef {} }")]
fn test_sysml_usages_parse(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Round-Trip Parse Tests - Control Nodes
// ============================================================================

#[rstest]
#[case("action def Test { fork; }")]
#[case("action def Test { fork myFork; }")]
#[case("action def Test { merge; }")]
#[case("action def Test { merge myMerge; }")]
#[case("action def Test { join; }")]
#[case("action def Test { join myJoin; }")]
#[case("action def Test { decide; }")]
#[case("action def Test { decide myDecision; }")]
fn test_control_nodes_parse(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Round-Trip Parse Tests - State Actions
// ============================================================================

#[rstest]
#[case("state def Test { entry myEntryAction; }")]
#[case("state def Test { exit myExitAction; }")]
#[case("state def Test { do myDoAction; }")]
fn test_state_actions_parse(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Round-Trip Parse Tests - Transitions
// ============================================================================

#[rstest]
#[case("state def Test { transition first a then b; }")]
#[case("package Test { first source then target; }")]
#[case("package Test { succession mySuccession first source then target; }")]
fn test_transitions_parse(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Round-Trip Parse Tests - Requirements
// ============================================================================

#[rstest]
#[case("requirement def Test { subject mySubject; }")]
#[case("requirement def Test { actor myActor; }")]
#[case("requirement def Test { stakeholder myStakeholder; }")]
#[case("requirement def Test { require myConstraint; }")]
#[case("requirement def Test { assume myConstraint; }")]
#[case("requirement def Test { frame myConcern; }")]
#[case("requirement def Test { verify myVerification; }")]
fn test_requirement_members_parse(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Round-Trip Parse Tests - Case Members
// ============================================================================

#[rstest]
#[case("case def Test { objective myObj; }")]
fn test_case_members_parse(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Round-Trip Parse Tests - Expose
// ============================================================================

#[rstest]
#[case("package Test { expose MyElement; }")]
fn test_expose_parse(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Round-Trip Parse Tests - Variant
// ============================================================================

#[rstest]
#[case("part def Test { variant myVariant; }")]
fn test_variant_parse(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Round-Trip Parse Tests - Terminate
// ============================================================================

#[rstest]
#[case("action def Test { terminate myOccurrence; }")]
fn test_terminate_parse(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Round-Trip Parse Tests - Dependencies
// ============================================================================

#[rstest]
#[case("dependency from A to B;")]
#[case("dependency A to B;")]
#[case("dependency myDep from A to B;")]
#[case("dependency from A, B to C, D;")]
#[case("dependency from A to B {}")]
fn test_dependency_parse(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Round-Trip Parse Tests - Comments and Documentation
// ============================================================================

#[rstest]
#[case("package Test { comment /* text */ }")]
#[case("package Test { comment MyComment /* text */ }")]
#[case("package Test { comment about Foo /* text */ }")]
#[case("package Test { comment about Foo, Bar /* text */ }")]
#[case("package Test { doc /* documentation */ }")]
#[case("package Test { doc MyDoc /* text */ }")]
fn test_comments_documentation_parse(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Round-Trip Parse Tests - Metadata
// ============================================================================

#[rstest]
#[case("package Test { #MyMetadata }")]
#[case("package Test { metadata MyMetadata; }")]
#[case("package Test { @MyMetadata; }")]
#[case("package Test { metadata MyMetadata about A, B; }")]
#[case("package Test { metadata myMeta : MyMetadata; }")]
#[case("package Test { metadata MyMetadata {} }")]
fn test_metadata_parse(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Round-Trip Parse Tests - Imports
// ============================================================================

#[rstest]
#[case("import MyElement;")]
#[case("public import MyElement;")]
#[case("import all MyElement;")]
#[case("import MyElement::*;")]
#[case("import MyElement::**;")]
#[case("import MyElement::*::**;")]
#[case("import MyElement {}")]
fn test_import_variations_parse(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Round-Trip Parse Tests - Aliases
// ============================================================================

#[rstest]
#[case("package Test { alias MyAlias for MyElement; }")]
#[case("package Test { private alias MyAlias for MyElement; }")]
fn test_alias_parse(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Round-Trip Parse Tests - Bindings and Connectors
// ============================================================================

#[rstest]
#[case("package Test { bind source = target; }")]
#[case("package Test { connect a to b; }")]
#[case("package Test { connection myConn connect a to b; }")]
fn test_bindings_connectors_parse(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Round-Trip Parse Tests - Feature Values
// ============================================================================

#[rstest]
#[case("package Test { attribute x = 42; }")]
#[case("package Test { attribute x := 42; }")]
#[case("package Test { attribute x default 42; }")]
#[case("package Test { attribute x default = 42; }")]
fn test_feature_values_parse(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Round-Trip Parse Tests - Typing and Multiplicity
// ============================================================================

#[rstest]
#[case("package Test { part x : Type; }")]
#[case("package Test { part x : Type[1]; }")]
#[case("package Test { part x : Type[0..*]; }")]
#[case("package Test { part x : Type[*]; }")]
#[case("package Test { part x[1..*] : Type; }")]
#[case("package Test { part x[0..*] ordered; }")]
#[case("package Test { part x[0..*] nonunique; }")]
#[case("package Test { part x[0..*] ordered nonunique; }")]
fn test_typing_multiplicity_parse(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Round-Trip Parse Tests - Specializations
// ============================================================================

#[rstest]
#[case("part def A :> B;")]
#[case("part def A specializes B;")]
#[case("part def A :> B, C;")]
#[case("package Test { part a subsets b; }")]
#[case("package Test { part a redefines b; }")]
#[case("package Test { part a :>> b; }")]
#[case("package Test { part a references b; }")]
#[case("package Test { part a ::> b; }")]
fn test_specializations_parse(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Round-Trip Parse Tests - Expressions
// ============================================================================

#[rstest]
#[case("package Test { attribute x = a + b; }")]
#[case("package Test { attribute x = a - b; }")]
#[case("package Test { attribute x = a * b; }")]
#[case("package Test { attribute x = a / b; }")]
#[case("package Test { attribute x = a == b; }")]
#[case("package Test { attribute x = a != b; }")]
#[case("package Test { attribute x = a < b; }")]
#[case("package Test { attribute x = a > b; }")]
#[case("package Test { attribute x = a and b; }")]
#[case("package Test { attribute x = a or b; }")]
#[case("package Test { attribute x = a xor b; }")]
#[case("package Test { attribute x = a implies b; }")]
#[case("package Test { attribute x = if a ? b else c; }")]
#[case("package Test { attribute x = a ?? b; }")]
fn test_expressions_parse(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Round-Trip Parse Tests - Invocations
// ============================================================================

#[rstest]
#[case("package Test { attribute x = foo(); }")]
#[case("package Test { attribute x = foo(a); }")]
#[case("package Test { attribute x = foo(a, b); }")]
#[case("package Test { attribute x = Pkg::foo(); }")]
fn test_invocations_parse(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Round-Trip Parse Tests - Send/Accept Actions
// ============================================================================

#[rstest]
#[case("action def Test { send msg to target; }")]
#[case("action def Test { accept msg; }")]
#[case("action def Test { accept msg via channel; }")]
fn test_send_accept_parse(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Round-Trip Parse Tests - Perform Actions
// ============================================================================

#[rstest]
#[case("action def Test { perform myAction; }")]
fn test_perform_parse(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Round-Trip Parse Tests - If Actions
// ============================================================================

#[rstest]
#[case("action def Test { if cond then a; }")]
#[case("action def Test { if cond then a else b; }")]
fn test_if_actions_parse(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Round-Trip Parse Tests - Loop Actions
// ============================================================================

#[rstest]
#[case("action def Test { while cond loop body; }")]
#[case("action def Test { loop body until cond; }")]
#[case("action def Test { for x : Type in items loop body; }")]
fn test_loop_actions_parse(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Round-Trip Parse Tests - Assign Actions
// ============================================================================

#[rstest]
#[case("action def Test { assign x := value; }")]
fn test_assign_parse(#[case] input: &str) {
    assert_parses(input);
}

// ============================================================================
// Multiple Members Tests
// ============================================================================

#[test]
fn test_multiple_definitions() {
    let input = r#"
        part def A;
        part def B;
        part def C;
    "#;
    let file = assert_parses_with_members(input, 3);

    for member in file.members() {
        match member {
            NamespaceMember::Definition(_) => {}
            other => panic!("Expected Definition, got {:?}", other),
        }
    }
}

#[test]
fn test_package_with_multiple_members() {
    let input = r#"
        package Test {
            import ISQ::*;
            part def Vehicle;
            part myPart : Vehicle;
        }
    "#;
    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();
    assert_eq!(members.len(), 1);

    match &members[0] {
        NamespaceMember::Package(pkg) => {
            let pkg_members: Vec<_> = pkg.members().collect();
            assert!(pkg_members.len() >= 2, "Package should have multiple members");
        }
        _ => panic!("Expected Package"),
    }
}

// ============================================================================
// Complex Nested Structure Tests
// ============================================================================

#[test]
fn test_part_with_nested_parts() {
    let input = r#"part def Vehicle {
        part engine : Engine;
        part wheels : Wheel[4];
    }"#;

    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();

    match &members[0] {
        NamespaceMember::Definition(def) => {
            let nested: Vec<_> = def.members().collect();
            assert_eq!(nested.len(), 2, "Should have 2 nested parts");
        }
        _ => panic!("Expected Definition"),
    }
}

#[test]
fn test_action_with_control_flow() {
    let input = r#"action def MyAction {
        action step1;
        action step2;
        first step1 then step2;
    }"#;

    assert_parses(input);
}

// ============================================================================
// Standard Library Pattern Tests
// ============================================================================

#[test]
fn test_standard_library_pattern() {
    let input = r#"standard library package ISQ {
        import SI::*;
        attribute def Length :> ScalarQuantityValue;
        attribute def Mass :> ScalarQuantityValue;
    }"#;

    let file = parse_source(input);
    let members: Vec<_> = file.members().collect();

    match &members[0] {
        NamespaceMember::LibraryPackage(lib) => {
            assert!(lib.is_standard());
            assert_eq!(lib.name().and_then(|n| n.text()), Some("ISQ".to_string()));
        }
        _ => panic!("Expected LibraryPackage"),
    }
}

// ============================================================================
// Part Definition and Usage Tests (from lines 2424-2500)
// ============================================================================

#[rstest]
#[case("part def MyPart;", "simple part definition")]
#[case("part def MyPart { }", "part definition with body")]
#[case("abstract part def MyPart;", "part definition with abstract prefix")]
#[case("individual part def UniquePart;", "part definition with individual marker")]
#[case("variation part def PartVariants;", "part definition with variation")]
#[case("part def MyPart :> Base;", "part definition with specialization")]
#[case("part def MyPart :> Base, Other;", "part definition with multiple specializations")]
fn test_part_definition_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case("package T { part myPart; }", "simple part usage")]
#[case("package T { part myPart { } }", "part usage with body")]
#[case("package T { ref individual part uniquePart; }", "part usage with ref and individual marker")]
#[case("package T { snapshot part snap1; }", "part usage with portion kind")]
#[case("package T { timeslice part slice1; }", "part usage with timeslice")]
fn test_part_usage_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Port Definition and Usage Tests (from lines 2500-2560)
// ============================================================================

#[rstest]
#[case("port def MyPort;", "simple port definition")]
#[case("port def MyPort { }", "port definition with body")]
#[case("port def ~ConjugatedPort;", "conjugated port definition")]
fn test_port_definition_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case("package T { port myPort; }", "simple port usage")]
#[case("package T { port myPort { } }", "port usage with body")]
#[case("package T { port drive: ~DriveIF; }", "port usage with conjugated type")]
#[case("package T { ref individual port uniquePort; }", "port usage with ref and individual marker")]
#[case("package T { snapshot port snap1; }", "port usage with portion kind")]
fn test_port_usage_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Connector and Binding Tests (from lines 2560-2640)
// ============================================================================

#[rstest]
#[case("package T { bind source = target; }", "simple binding connector")]
#[case("package T { bind source = target { } }", "binding connector with body")]
#[case("package T { binding myBinding bind source = target; }", "binding connector with declaration")]
fn test_binding_connector_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case("package T { connect a to b; }", "binary connector")]
#[case("package T { connect (a, b, c); }", "nary connector")]
#[case("package T { connection myConn connect a to b; }", "connection with declaration")]
fn test_connector_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Connection Definition and Usage Tests (from lines 2640-2730)
// ============================================================================

#[rstest]
#[case("connection def MyConnection;", "simple connection definition")]
#[case("connection def MyConnection { }", "connection definition with body")]
#[case("abstract connection def MyConnection;", "connection definition with abstract prefix")]
fn test_connection_definition_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case("package T { connection myConn; }", "simple connection usage")]
#[case("package T { connection myConn { } }", "connection usage with body")]
#[case("package T { connect source to target; }", "connection usage with connector")]
#[case("package T { connection myConn connect source to target; }", "connection usage with declaration and connector")]
#[case("package T { connect (a, b, c); }", "connection usage with nary connector")]
fn test_connection_usage_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Interface Definition and Usage Tests (from lines 2730-2950)
// ============================================================================

#[rstest]
#[case("interface def MyInterface;", "simple interface definition with semicolon")]
#[case("interface def Vehicle { port driver; }", "interface definition with port")]
#[case("abstract interface def DataInterface { ref data : DataType; }", "abstract interface with reference usage")]
#[case("interface def FuelingInterface { end fuelOutPort : FuelingPort; end fuelInPort : ~FuelingPort; }", "interface def with end features")]
fn test_interface_definition_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case("package T { interface connect left to right; }", "simple interface usage")]
#[case("package T { interface connect left to right{} }", "interface with empty body")]
#[case("package T { interface leftFrontMount: Mounting connect frontAxle.leftMountingPoint to leftFrontWheel.hub; }", "interface with typing")]
#[case("package T { interface driveShaft connect transDrive ::> transmission.drive to axleDrive ::> rearAxle.drive; }", "interface with ::> operator")]
fn test_interface_usage_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Flow Definition and Usage Tests (from lines 2960-3070)
// ============================================================================

#[rstest]
#[case("flow def DataFlow;", "simple flow definition with semicolon")]
#[case("flow def FluidFlow { }", "flow definition with body")]
#[case("abstract flow def AbstractFlow;", "abstract flow definition")]
fn test_flow_definition_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case("package T { flow myFlow; }", "simple flow usage")]
#[case("package T { flow a to b; }", "flow with endpoints")]
#[case("package T { flow a.b to c.d; }", "flow with feature chains")]
#[case("package T { flow b.f.a to c.aa; }", "flow with three-part source, two-part target")]
#[case("package T { flow of Exposure from focus.xrsl to shoot.xsf; }", "typed flow with from-to")]
#[case("package T { flow publish of Publish from a.b to c.d; }", "named typed flow")]
fn test_flow_usage_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Succession Flow Tests
// ============================================================================

#[rstest]
#[case("package T { succession flow x.p to a.b; }", "succession flow with chains")]
#[case("package T { succession flow a to b; }", "succession flow simple")]
fn test_succession_flow_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Action Definition and Usage Tests (from lines 3070-3400)
// ============================================================================

#[rstest]
#[case("action def Move;", "simple action definition with semicolon")]
#[case("action def Calculate { }", "action definition with body")]
#[case("abstract action def AbstractAction;", "abstract action definition")]
#[case("action def Process (in data, out result) { }", "action def with params")]
#[case("action def Drive :> Action;", "action def with specialization")]
fn test_action_definition_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case("package T { action myAction; }", "simple action usage")]
#[case("package T { action myAction { } }", "action usage with body")]
#[case("package T { action doSomething; }", "action usage simple")]
fn test_action_usage_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Action Control Flow Tests
// ============================================================================

#[rstest]
#[case("action def T { first start; then merge m; }", "action with first and merge")]
#[case("action def T { first start; then decide d; }", "action with first and decide")]
#[case("action def T { first A1 then A2; }", "simple succession")]
#[case("action def T { succession S first A1 then A2; }", "named succession")]
#[case("action def T { first A1 if x == 0 then A2; }", "succession with guard")]
#[case("action def T { first A1 else A2; }", "succession with default")]
fn test_action_control_flow_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Perform Action Tests
// ============================================================================

#[rstest]
#[case("package T { perform c.incr; }", "perform with feature chain")]
#[case("package T { perform myAction; }", "perform with reference")]
fn test_perform_action_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Accept Node Tests (from lines 3440-3600)
// ============================================================================

#[rstest]
#[case("action def T { accept msg; }", "accept node with identifier")]
#[case("action def T { accept S; }", "accept node with bare type name")]
#[case("action def T { accept signal : SignalType; }", "accept node with typed payload")]
#[case("action def T { accept sig after 10; }", "accept with after")]
#[case("action def T { accept at timeValue; }", "accept with at trigger")]
#[case("action def T { accept when condition; }", "accept with when trigger")]
fn test_accept_node_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Send Node Tests
// ============================================================================

#[rstest]
#[case("action def T { send msg to target; }", "send node with target")]
#[case("action def T { send msg via port; }", "send node with via")]
#[case("action def T { send msg via port to target; }", "send node with via and to")]
fn test_send_node_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Assignment Node Tests (from lines 3720-3810)
// ============================================================================

#[rstest]
#[case("action def T { assign x := y; }", "simple assignment")]
#[case("action def T { assign count := count + 1; }", "increment assignment")]
#[case("action def T { assign counter.count := 0; }", "feature chain assignment")]
#[case("action def T { assign counter.count := counter.count + 1; }", "feature chain self-increment")]
fn test_assignment_node_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Loop and Conditional Tests (from lines 4200-4300)
// ============================================================================

#[rstest]
#[case("action def T { if condition {} }", "if with condition")]
#[case("action def T { if x {} else {} }", "if with else")]
#[case("action def T { while condition {} }", "while loop")]
#[case("action def T { loop {} }", "unconditional loop")]
#[case("action def T { loop {} until result; }", "loop with until")]
#[case("action def T { for x in items {} }", "for loop")]
fn test_loop_conditional_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Terminate Node Tests
// ============================================================================

#[rstest]
#[case("action def T { terminate; }", "simple terminate")]
fn test_terminate_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// State Definition and Usage Tests (from lines 4300-4600)
// ============================================================================

#[rstest]
#[case("state def MyState;", "simple state definition")]
#[case("state def MyState {}", "state definition with empty body")]
#[case("state def MyState parallel {}", "parallel state definition")]
#[case("abstract state def MyState;", "abstract state definition")]
fn test_state_definition_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case("package T { state myState; }", "simple state usage")]
#[case("package T { state myState {} }", "state usage with empty body")]
#[case("package T { state myState parallel {} }", "parallel state usage")]
#[case("package T { exhibit state myState; }", "exhibit state usage")]
fn test_state_usage_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// State Action Member Tests
// ============================================================================

#[rstest]
#[case("state def T { entry action entryAction; }", "full form entry action")]
#[case("state def T { entry; }", "empty entry action shorthand")]
#[case("state def T { entry setupSensor; }", "entry reference subsetting shorthand")]
#[case("state def T { do action doAction; }", "full form do action")]
#[case("state def T { do; }", "empty do action shorthand")]
#[case("state def T { do monitorTemperature; }", "do reference subsetting shorthand")]
#[case("state def T { exit action exitAction; }", "full form exit action")]
#[case("state def T { exit; }", "empty exit action shorthand")]
#[case("state def T { exit cleanup; }", "exit reference subsetting shorthand")]
fn test_state_action_member_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Transition Usage Tests (from lines 4700-4900)
// ============================================================================

#[rstest]
#[case("state def T { transition first S1 then S2; }", "anonymous transition")]
#[case("state def T { transition T first S1 then S2; }", "named transition with first")]
#[case("state def T { transition initial then off; }", "transition from initial")]
fn test_transition_usage_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Allocate Usage Tests (from lines 4900-5000)
// ============================================================================

#[rstest]
#[case("package T { allocate a to b; }", "simple allocate")]
#[case("package T { allocate l.component to assembly.element; }", "allocate with feature chains")]
#[case("package T { allocation myAlloc; }", "simple allocation usage")]
#[case("package T { allocation allocation1 : Logical_to_Physical allocate l to p; }", "allocation with name, type and allocate")]
fn test_allocate_usage_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Calculation Definition and Usage Tests (from lines 4900-5000)
// ============================================================================

#[rstest]
#[case("calc def MyCalc;", "simple calculation definition")]
#[case("calc def MyCalc {}", "calculation definition with empty body")]
#[case("calc def Increment { in c : Counter; return : Counter; perform c.incr; c }", "full calculation definition")]
#[case("calc def Torque (current:>SI::A, voltage:>ISQ::voltage):> ISQ::torque { }", "calc with params and return type")]
fn test_calculation_definition_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case("package T { calc myCalc; }", "simple calculation usage")]
#[case("package T { calc myCalc {} }", "calculation usage with body")]
fn test_calculation_usage_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Constraint Definition and Usage Tests (from lines 5000-5100)
// ============================================================================

#[rstest]
#[case("constraint def MyConstraint;", "simple constraint definition")]
#[case("constraint def MyConstraint {}", "constraint definition with body")]
fn test_constraint_definition_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case("package T { constraint myConstraint; }", "simple constraint usage")]
#[case("package T { constraint myConstraint {} }", "constraint usage with body")]
#[case("package T { assert constraint {} }", "assert constraint usage")]
#[case("package T { assert myRef; }", "assert constraint with reference")]
#[case("package T { assert not myRef; }", "assert constraint with negation")]
fn test_constraint_usage_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Requirement Definition and Usage Tests (from lines 5100-5500)
// ============================================================================

#[rstest]
#[case("requirement def SafetyRequirement;", "requirement definition with semicolon")]
#[case("requirement def SafetyRequirement {}", "requirement definition with empty body")]
#[case("requirement def <'REQ-1'> SafetyReq { }", "requirement def with short name")]
fn test_requirement_definition_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case("package T { requirement myReq; }", "simple requirement usage")]
#[case("package T { satisfy requirement; }", "satisfy requirement")]
#[case("package T { satisfy Requirements::REQ1 by RoboticVacuumCleaner::battery; }", "satisfy with qualified name by clause")]
#[case("package T { satisfy req by system.component.feature; }", "satisfy with feature chain by clause")]
#[case("package T { assert satisfy r by q; }", "assert satisfy")]
#[case("package T { assert not satisfy r1 by q; }", "assert not satisfy")]
fn test_requirement_usage_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Requirement Body Member Tests
// ============================================================================

#[rstest]
#[case("requirement def T { subject mySubject; }", "subject usage")]
#[case("requirement def T { subject subj : MyType; }", "subject usage with typing")]
#[case("requirement def T { subject subj default myValue; }", "subject usage with default")]
#[case("requirement def T { actor myActor; }", "actor usage")]
#[case("requirement def T { stakeholder myStakeholder; }", "stakeholder usage")]
#[case("requirement def T { assume myConstraint {} }", "assume requirement constraint")]
#[case("requirement def T { require constraint {} }", "require requirement constraint")]
#[case("requirement def T { frame myConcern; }", "framed concern")]
#[case("requirement def T { verify myVerification; }", "requirement verification")]
fn test_requirement_body_member_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Concern Definition and Usage Tests (from lines 5200-5300)
// ============================================================================

#[rstest]
#[case("concern def PerformanceConcern;", "concern definition with semicolon")]
#[case("concern def PerformanceConcern {}", "concern definition with empty body")]
#[case("concern def SafetyConcern { subject vehicle; stakeholder driver; }", "concern definition with subject and stakeholder")]
fn test_concern_definition_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case("package T { concern myConcern {} }", "concern usage")]
fn test_concern_usage_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Case Definition and Usage Tests (from lines 5300-5500)
// ============================================================================

#[rstest]
#[case("case def TestCase;", "case definition with semicolon")]
#[case("case def TestCase {}", "case definition with empty body")]
#[case("case def TestCase { subject testSubject; }", "case definition with subject")]
fn test_case_definition_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case("package T { case testCase; }", "case usage with semicolon")]
#[case("package T { case testCase {} }", "case usage with empty body")]
#[case("package T { case testCase { subject testSubject; } }", "case usage with subject")]
#[case("case def T { objective myObjective {} }", "case with objective")]
fn test_case_usage_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Analysis Case Tests (from lines 5500-5600)
// ============================================================================

#[rstest]
#[case("analysis def AnalysisTest;", "analysis case definition with semicolon")]
#[case("analysis def AnalysisTest {}", "analysis case definition with empty body")]
#[case("analysis def AnalysisTest { subject testSubject; }", "analysis case definition with subject")]
fn test_analysis_case_definition_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case("package T { analysis testAnalysis; }", "analysis case usage with semicolon")]
#[case("package T { analysis testAnalysis {} }", "analysis case usage with empty body")]
#[case("package T { analysis testAnalysis { actor analyst; } }", "analysis case usage with actor")]
fn test_analysis_case_usage_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Verification Case Tests (from lines 5600-5700)
// ============================================================================

#[rstest]
#[case("verification def VerifyTest;", "verification case definition with semicolon")]
#[case("verification def VerifyTest {}", "verification case definition with empty body")]
#[case("verification def VerifyTest { objective myObj {} }", "verification case definition with objective")]
fn test_verification_case_definition_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case("package T { verification testVerification; }", "verification case usage with semicolon")]
#[case("package T { verification testVerification {} }", "verification case usage with empty body")]
fn test_verification_case_usage_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Use Case Tests (from lines 5700-5800)
// ============================================================================

#[rstest]
#[case("use case def TestUseCase;", "use case definition with semicolon")]
#[case("use case def TestUseCase {}", "use case definition with empty body")]
fn test_use_case_definition_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case("package T { use case transportPassenger:TransportPassenger; }", "use case usage typed")]
#[case("package T { include use case uc1 : UC1; }", "include use case with typing")]
#[case("package T { include uc2; }", "include shorthand")]
fn test_use_case_usage_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// View Definition and Usage Tests (from lines 5800-5900)
// ============================================================================

#[rstest]
#[case("view def TestView;", "view definition with semicolon")]
#[case("view def TestView {}", "view definition with empty body")]
fn test_view_definition_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case("package T { view myView; }", "view usage with semicolon")]
#[case("package T { view myView {} }", "view usage with empty body")]
#[case("package T { render myRendering; }", "view rendering member")]
fn test_view_usage_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Viewpoint Definition and Usage Tests (from lines 5900-5980)
// ============================================================================

#[rstest]
#[case("viewpoint def TestViewpoint;", "viewpoint definition with semicolon")]
#[case("viewpoint def TestViewpoint {}", "viewpoint definition with empty body")]
#[case("viewpoint def TestViewpoint { stakeholder user; }", "viewpoint definition with stakeholder")]
fn test_viewpoint_definition_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case("package T { viewpoint myViewpoint; }", "viewpoint usage with semicolon")]
#[case("package T { viewpoint myViewpoint {} }", "viewpoint usage with empty body")]
fn test_viewpoint_usage_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Rendering Definition and Usage Tests (from lines 5980-6000)
// ============================================================================

#[rstest]
#[case("rendering def TestRendering;", "rendering definition with semicolon")]
#[case("rendering def TestRendering {}", "rendering definition with empty body")]
fn test_rendering_definition_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case("package T { rendering myRendering; }", "rendering usage")]
fn test_rendering_usage_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Expression Tests (from lines 6000-6400)
// ============================================================================

#[rstest]
#[case("package T { attribute x = myValue; }", "identifier")]
#[case("package T { attribute x = \"test\"; }", "string literal")]
#[case("package T { attribute x = 123; }", "integer literal")]
#[case("package T { attribute x = false; }", "boolean literal")]
#[case("package T { attribute x = if a ? b else c; }", "conditional expression")]
#[case("package T { attribute x = a ?? b; }", "null coalescing expression")]
#[case("package T { attribute x = a implies b; }", "implies expression")]
#[case("package T { attribute x = a | b; }", "or expression with pipe")]
#[case("package T { attribute x = a or b; }", "or expression with keyword")]
#[case("package T { attribute x = a xor b; }", "xor expression")]
#[case("package T { attribute x = a & b; }", "and expression with ampersand")]
#[case("package T { attribute x = a and b; }", "and expression with keyword")]
fn test_expression_logical_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case("package T { attribute x = a == b; }", "equality ==")]
#[case("package T { attribute x = a != b; }", "inequality !=")]
#[case("package T { attribute x = a === b; }", "strict equality ===")]
#[case("package T { attribute x = a !== b; }", "strict inequality !==")]
fn test_expression_equality_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case("package T { attribute x = value hastype Type; }", "hastype classification")]
#[case("package T { attribute x = value istype Type; }", "istype classification")]
#[case("package T { attribute x = value @ Type; }", "@ classification")]
#[case("package T { attribute x = value as Type; }", "as cast")]
fn test_expression_classification_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case("package T { attribute x = a < b; }", "less than")]
#[case("package T { attribute x = a > b; }", "greater than")]
#[case("package T { attribute x = a <= b; }", "less than or equal")]
#[case("package T { attribute x = a >= b; }", "greater than or equal")]
fn test_expression_relational_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case("package T { attribute x = 1..10; }", "range expression")]
fn test_expression_range_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case("package T { attribute x = a + b; }", "addition")]
#[case("package T { attribute x = a - b; }", "subtraction")]
#[case("package T { attribute x = a + b - c; }", "chained additive")]
fn test_expression_additive_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case("package T { attribute x = a * b; }", "multiplication")]
#[case("package T { attribute x = a / b; }", "division")]
#[case("package T { attribute x = a % b; }", "modulo")]
fn test_expression_multiplicative_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case("package T { attribute x = a ** b; }", "exponentiation **")]
#[case("package T { attribute x = a ^ b; }", "exponentiation ^")]
fn test_expression_exponentiation_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case("package T { attribute x = +value; }", "unary plus")]
#[case("package T { attribute x = -value; }", "unary minus")]
#[case("package T { attribute x = ~value; }", "unary bitwise not")]
#[case("package T { attribute x = not value; }", "unary logical not")]
fn test_expression_unary_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Literal Tests
// ============================================================================

#[rstest]
#[case("package T { attribute x = \"hello world\"; }", "string literal")]
#[case("package T { attribute x = \"\"; }", "empty string")]
#[case("package T { attribute x = 42; }", "positive integer")]
#[case("package T { attribute x = -42; }", "negative integer")]
#[case("package T { attribute x = 3.14; }", "decimal number")]
#[case("package T { attribute x = -3.14; }", "negative decimal")]
#[case("package T { attribute x = true; }", "boolean true")]
#[case("package T { attribute x = false; }", "boolean false")]
#[case("package T { attribute x = null; }", "null literal")]
fn test_literal_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Argument List Tests
// ============================================================================

#[rstest]
#[case("package T { attribute x = foo(); }", "empty argument list")]
#[case("package T { attribute x = foo(arg); }", "one positional arg")]
#[case("package T { attribute x = foo(arg1, arg2); }", "multiple positional args")]
#[case("package T { attribute x = foo(arg1, arg2, arg3); }", "three positional args")]
#[case("package T { attribute x = foo(param1 = value1); }", "one named arg")]
#[case("package T { attribute x = foo(param1 = value1, param2 = value2); }", "multiple named args")]
fn test_argument_list_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Invocation Expression Tests
// ============================================================================

#[rstest]
#[case("package T { attribute x = MyType(); }", "invocation with empty args")]
#[case("package T { attribute x = MyType(arg); }", "invocation with one arg")]
#[case("package T { attribute x = MyType(arg1, arg2); }", "invocation with multiple args")]
#[case("package T { attribute x = MyType(param = value); }", "invocation with named arg")]
#[case("package T { attribute x = foo.bar(x); }", "dotted invocation")]
#[case("package T { attribute x = PassIf(spec.req(uut)); }", "nested invocation")]
fn test_invocation_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Measurement Reference Tests (from lines 8500-8600)
// ============================================================================

#[rstest]
#[case("package T { attribute x = 5 [kg]; }", "value with unit")]
#[case("package T { attribute x = 120.5 [min]; }", "decimal with unit")]
#[case("package T { attribute x = 0 [SI::m]; }", "qualified unit")]
fn test_measurement_reference_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Import Variants Tests
// ============================================================================

#[rstest]
#[case("import q;", "single-char import")]
#[case("import myPackage;", "named import")]
#[case("import A::B;", "qualified import")]
#[case("import A::B::C;", "multi-level qualified import")]
#[case("import q::**;", "single-char recursive import")]
#[case("import myPackage::**;", "named recursive import")]
#[case("import A::B::**;", "qualified recursive import")]
#[case("import q::*;", "single-char namespace import")]
#[case("import myPackage::*;", "named namespace import")]
#[case("import A::B::*;", "qualified namespace import")]
fn test_import_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Expose Variants Tests
// ============================================================================

#[rstest]
#[case("package T { expose MyNamespace::*; }", "namespace expose with wildcard")]
#[case("package T { expose A::B::*; }", "qualified namespace expose")]
#[case("package T { expose MyPackage::*::**; }", "namespace expose with recursive")]
#[case("package T { expose MyElement; }", "simple membership expose")]
#[case("package T { expose A::B::C; }", "qualified membership expose")]
fn test_expose_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Textual Representation Tests (from lines 7400-7450)
// ============================================================================

#[rstest]
#[case("action def T { language \"ocl\" /* code */ }", "language statement")]
#[case("action def T { rep language \"ocl\" /* code */ }", "rep without name")]
#[case("action def T { rep inOCL language \"ocl\" /* code */ }", "rep with name")]
fn test_textual_representation_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Redefinition Tests (from lines 7450-7550)
// ============================================================================

#[rstest]
#[case("package T { attribute :>> localClock.currentTime; }", "anonymous attribute with redefinition")]
#[case("package T { attribute :>> localClock.currentTime = startTime + elapseTime; }", "anonymous attribute with redefinition and value")]
#[case("package T { part cylinders :>> cylinders [4]; }", "part with redefinition and multiplicity")]
#[case("package T { attribute mass redefines mass = 180 [kg]; }", "attribute redefines with value and unit")]
fn test_redefinition_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Variation Tests (from lines 7700-7780)
// ============================================================================

#[rstest]
#[case("variation part def V :> P { variant part x : Q { attribute b : B; } }", "variation part def")]
#[case("package T { variation part v : P { variant q { attribute b : B; } } }", "variation part usage")]
fn test_variation_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Dependency with Metadata Tests (from lines 7900-8000)
// ============================================================================

#[rstest]
#[case("dependency from A to B;", "simple dependency")]
#[case("#refinement dependency engine4Cyl to VehicleConfiguration::PartsTree::vehicle::engine;", "refinement dependency")]
fn test_dependency_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Metadata with About Tests (from lines 8100-8150)
// ============================================================================

#[rstest]
#[case("package T { @Rationale { text = \"reasoning\"; } }", "metadata with body")]
#[case("package T { @Rationale about myElement { text = \"reasoning\"; } }", "metadata about element")]
fn test_metadata_about_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Short Name Tests (from lines 8400-8450)
// ============================================================================

#[rstest]
#[case("part def A { part <'1'> b: B; }", "part with quoted short name")]
#[case("part def <myId> Test;", "definition with identifier short name")]
fn test_short_name_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Complex Package Tests
// ============================================================================

#[test]
fn test_complex_package_with_parts() {
    let input = r#"package Test {
        part def Counter {
            attribute count : Integer := 0;
            action incr { assign count := count + 1; }
            action decr { assign count := count - 1; }
        }
        attribute def Incr;
        attribute def Decr;
    }"#;
    assert_parses(input);
}

#[test]
fn test_state_def_with_entry_and_do_assignments() {
    let input = r#"state def Counting {
        part counter : Counter;
        entry assign counter.count := 0;
        then state wait;
        accept Incr then increment;
        accept Decr then decrement;
        state increment { do assign counter.count := counter.count + 1; }
        then wait;
        state decrement { do assign counter.count := counter.count - 1; }
        then wait;
    }"#;
    assert_parses(input);
}

#[test]
fn test_calc_def_with_perform() {
    let input = r#"calc def Increment {
        in c : Counter;
        return : Counter;
        perform c.incr;
        c
    }"#;
    assert_parses(input);
}

#[test]
fn test_action_with_state_and_assignments() {
    let input = r#"action a {
        state counting : Counting;
        assign counting.counter.count := counting.counter.count + 1;
        assign counting.counter.count := Increment(counting.counter).count;
    }"#;
    assert_parses(input);
}

#[test]
fn test_decision_test_action_def() {
    let input = r#"action def DecisionTest {
        attribute x = 1;
        decide 'test x';
        if x == 1 then A1;
        if x > 1 then A2;
        else A3;
        then decide D;
        if true then A1;
        if false then A2;
        action A1;
        action A2;
        action A3;
        succession S first A1 if x == 0 then A2;
        first A3;
        if x > 0 then 'test x';
    }"#;
    assert_parses(input);
}

#[test]
fn test_interface_usage_with_flows() {
    let input = r#"package Test {
        occurrence def APIS_transfer_lifetime {
            interface APIS_transfer_interface : Interface connect (
                tlu ::> X.a,
                apsph ::> Y.b) {
                flow publish_returnallitems of Publish from apspm.pub to mqget.APIS_MQTT.pub;
                flow subscribe_returnallitems of Subscribe from apsc.subscr to mqgive.APIS_MQTT.subscr;
                flow call_getItems of CallGiveItems[1] from tlu.cll to apsph.cll;
            }
        }
    }"#;
    assert_parses(input);
}

#[test]
fn test_part_with_bind_and_interfaces() {
    let input = r#"part vehicle {
        bind engine.fuelCmdPort = fuelCmdPort;
        interface engineInterface:EngineInterface connect engine.port1 to trans.port2;
        interface fuelInterface:FuelInterface connect fuelTank.outPort to engine.inPort;
    }"#;
    assert_parses(input);
}

#[test]
fn test_allocation_def_with_end_features() {
    let input = r#"allocation def Logical_to_Physical :> A {
        end logical : Logical;
        end physical : Physical;
    }"#;
    assert_parses(input);
}

#[test]
fn test_derivation_connection_with_end_elements() {
    let input = r#"package T { #derivation connection : Req1_Derivation {
        end r1 ::> req1;
        end r1_1 ::> req1_1;
        end r1_2 ::> req1_2;
    } }"#;
    assert_parses(input);
}

#[test]
fn test_verification_with_actions() {
    let input = r#"verification massTests:MassTest {
        subject vehicle_uut :> vehicle_b;
        actor vehicleVerificationSubSystem_1 = verificationContext.massVerificationSystem;
        objective {
            verify vehicleSpecification.vehicleMassRequirement {
                redefines massActual = weighVehicle.massMeasured;
            }
        }
        action weighVehicle { out massMeasured:>ISQ::mass; }
        then action evaluatePassFail {
            in massMeasured:>ISQ::mass;
            out verdict = PassIf(vehicleSpecification.vehicleMassRequirement(vehicle_uut));
        }
        flow from weighVehicle.massMeasured to evaluatePassFail.massMeasured;
        return :>> verdict = evaluatePassFail.verdict;
    }"#;
    assert_parses(input);
}

#[test]
fn test_use_case_with_trigger_accept() {
    let input = r#"use case transportPassenger:TransportPassenger {
        first start;
        then action a { action driverGetInVehicle; }
        then action trigger accept ignitionCmd:IgnitionCmd;
        then action b { action driveVehicleToDestination; }
        then action c { action driverGetOutOfVehicle; }
        then done;
    }"#;
    assert_parses(input);
}

#[test]
fn test_part_test_file_pattern() {
    let input = r#"package PartTest {
        part f: A;
        public part def A {
            part <'1'> b: B;
            protected port c: C;
            constant attribute x[0..2];
            derived constant ref attribute y :> x;
            ref z : Integer;
        }
    }"#;
    assert_parses(input);
}

// ============================================================================
// Additional Definition Tests from disabled file (lines 1200-1300)
// ============================================================================

#[rstest]
#[case("attribute def MyAttribute;", "attribute definition")]
#[case("enum def MyEnum;", "enumeration definition")]
#[case("occurrence def MyOccurrence;", "occurrence definition")]
#[case("individual def MyIndividual;", "individual definition")]
#[case("item def MyItem;", "item definition")]
#[case("part def MyPart;", "part definition")]
#[case("connection def MyConnection;", "connection definition")]
#[case("interface def MyInterface;", "interface definition")]
#[case("allocation def MyAllocation;", "allocation definition")]
#[case("port def MyPort;", "port definition")]
#[case("action def MyAction;", "action definition")]
#[case("calc def MyCalc;", "calculation definition")]
#[case("state def MyState;", "state definition")]
#[case("constraint def MyConstraint;", "constraint definition")]
#[case("requirement def MyRequirement;", "requirement definition")]
#[case("concern def MyConcern;", "concern definition")]
#[case("case def MyCase;", "case definition")]
#[case("analysis def MyAnalysisCase;", "analysis case definition")]
#[case("verification def MyVerificationCase;", "verification case definition")]
#[case("use case def MyUseCase;", "use case definition")]
#[case("view def MyView;", "view definition")]
#[case("viewpoint def MyViewpoint;", "viewpoint definition")]
#[case("rendering def MyRendering;", "rendering definition")]
fn test_definition_element_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Subclassification Tests (lines 1280-1350)
// ============================================================================

#[rstest]
#[case("part def A :> Base;", "single base")]
#[case("part def A specializes Base;", "specializes keyword")]
#[case("part def A :> Base1, Base2;", "multiple bases")]
#[case("part def A :> Base1, Base2, Base3;", "three bases")]
fn test_subclassification_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Multiplicity Tests (lines 1350-1450)
// ============================================================================

#[rstest]
#[case("package T { part x[1]; }", "single bound")]
#[case("package T { part x[0..*]; }", "range with star")]
#[case("package T { part x[1..5]; }", "numeric range")]
#[case("package T { part x[*]; }", "unbounded")]
#[case("package T { part x[1] ordered; }", "multiplicity with ordered")]
#[case("package T { part x[*] nonunique; }", "multiplicity with nonunique")]
#[case("package T { part x[0..*] ordered nonunique; }", "multiplicity with both properties")]
fn test_multiplicity_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Feature Specialization Tests (lines 1450-1550)
// ============================================================================

#[rstest]
#[case("package T { part x : BaseType; }", "typed by")]
#[case("package T { part x :> BaseFeature; }", "subsets")]
#[case("package T { part x ::> ReferencedFeature; }", "references")]
#[case("package T { part x :>> RedefinedFeature; }", "redefines")]
#[case("package T { part x subsets BaseFeature; }", "subsets keyword")]
#[case("package T { part x redefines BaseFeature; }", "redefines keyword")]
#[case("package T { part x references BaseFeature; }", "references keyword")]
fn test_feature_specialization_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Feature Chain Tests (lines 1530-1570)
// ============================================================================

#[rstest]
#[case("package T { part x :> a.b; }", "simple chain")]
#[case("package T { part x :> a.b.c; }", "longer chain")]
#[case("package T { part x :> vehicle.engine.cylinder; }", "descriptive chain")]
fn test_feature_chain_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Definition Body Tests (lines 1620-1750)
// ============================================================================

#[rstest]
#[case("part def A;", "semicolon body")]
#[case("part def A { }", "empty body")]
#[case("part def A { part b; }", "body with usage")]
#[case("part def A { part b; part c; }", "body with multiple usages")]
fn test_definition_body_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Usage Modifier Tests (lines 1750-1850)
// ============================================================================

#[rstest]
#[case("package T { constant part x; }", "constant modifier")]
#[case("package T { derived part x; }", "derived modifier")]
#[case("package T { constant derived part x; }", "both modifiers")]
#[case("package T { readonly part x; }", "readonly modifier")]
fn test_usage_modifier_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Direction Tests (lines 1850-1900)
// ============================================================================

#[rstest]
#[case("action def T { in part x; }", "in direction")]
#[case("action def T { out part x; }", "out direction")]
#[case("action def T { inout part x; }", "inout direction")]
fn test_direction_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Feature Value Tests (lines 1900-2000)
// ============================================================================

#[rstest]
#[case("package T { attribute x = 42; }", "initial value with =")]
#[case("package T { attribute x := 42; }", "binding value with :=")]
#[case("package T { attribute x default 42; }", "default value")]
#[case("package T { attribute x default = 42; }", "default initial value")]
fn test_feature_value_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Visibility Tests (lines 2000-2100)
// ============================================================================

#[rstest]
#[case("public part def A;", "public definition")]
#[case("private part def A;", "private definition")]
#[case("protected part def A;", "protected definition")]
#[case("package T { public part x; }", "public usage")]
#[case("package T { private part x; }", "private usage")]
#[case("package T { protected part x; }", "protected usage")]
fn test_visibility_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Comment and Documentation Tests (lines 670-760)
// ============================================================================

#[rstest]
#[case(r#"package T { comment locale "en-US" /* comment text */ }"#, "comment with locale")]
#[case(r#"package T { comment MyComment locale "fr-FR" /* texte */ }"#, "named comment with locale")]
#[case(r#"package T { comment about Foo; }"#, "comment about element")]
#[case(r#"package T { comment about Foo, Bar; }"#, "comment about multiple")]
#[case(r#"package T { comment MyComment about Foo, Bar /* about multiple */ }"#, "named comment about multiple")]
fn test_comment_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case(r#"package T { doc locale "en-US" /* docs */ }"#, "doc with locale")]
#[case(r#"package T { doc MyDoc locale "ja-JP" /* text */ }"#, "named doc with locale")]
#[case(r#"package T { doc /* inline doc */ }"#, "inline doc")]
fn test_documentation_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Metadata Tests (lines 770-870)
// ============================================================================

#[rstest]
#[case("metadata def MyMetadata;", "simple metadata definition")]
#[case("abstract metadata def MyMetadata;", "abstract metadata definition")]
#[case("package T { #MyMetadata }", "prefix metadata usage")]
#[case("package T { metadata MyMetadata; }", "simple metadata usage")]
#[case("package T { @MyMetadata; }", "metadata usage with @")]
#[case("package T { metadata MyMetadata about A, B; }", "metadata usage with about")]
#[case("package T { metadata myMeta : MyMetadata; }", "metadata usage with defined by")]
#[case("package T { metadata MyMetadata { } }", "metadata usage with body")]
fn test_metadata_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Import Filter Tests (lines 1100-1200)
// ============================================================================

#[rstest]
#[case("import MyElement [condition];", "import with filter")]
#[case("import MyElement [filter1][filter2];", "import with multiple filters")]
#[case("import MyElement { }", "import with body")]
fn test_import_filter_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[test]
fn test_package_with_filter_statement() {
    let input = r#"package UpperLevelApprovals {
        public import DesignModel::**;
        filter @ApprovalMetadata::Approval and
            ApprovalMetadata::Approval::approved and
            ApprovalMetadata::Approval::level > 1;
    }"#;
    assert_parses(input);
}

#[test]
fn test_package_with_filtered_import() {
    let input = r#"package UpperLevelApprovals {
        private import ApprovalMetadata::**;
        public import DesignModel::**[@Approval and approved and level > 1];
    }"#;
    assert_parses(input);
}

// ============================================================================
// Case Body Tests (lines 880-980)
// ============================================================================

#[test]
fn test_cases_sysml_fragment() {
    let input = r#"abstract case def Case {
        subject subj : Anything[1] { }
        objective obj : RequirementCheck[1] {
            subject subj default Case::result;
        }
    }"#;
    assert_parses(input);
}

#[test]
fn test_simplified_case_with_objective() {
    let input = r#"case def Case {
        objective obj : RequirementCheck[1] {
            subject subj default Case::result;
        }
    }"#;
    assert_parses(input);
}

// ============================================================================
// State Tests (lines 990-1060)
// ============================================================================

#[test]
fn test_ref_state_usage() {
    let input = "package T { ref state myState; }";
    assert_parses(input);
}

#[test]
fn test_abstract_ref_state_usage() {
    let input = "part def T { abstract ref state exhibitedStates: StateAction[0..*] { } }";
    assert_parses(input);
}

#[test]
fn test_state_with_doc_comment() {
    let input = r#"part def T { abstract ref state exhibitedStates: StateAction[0..*] {
        doc /* StateActions that are exhibited by this Part. */
    } }"#;
    assert_parses(input);
}

// ============================================================================
// Constraint Tests (lines 1060-1100)
// ============================================================================

#[test]
fn test_constraint_with_doc_comment() {
    let input = r#"package T { assert constraint {
        doc /* Test constraint */
        innerSpaceDimension == value
    } }"#;
    assert_parses(input);
}

// ============================================================================
// Crosses Tests (lines 1440-1500)
// ============================================================================

#[rstest]
#[case("package T { part cart: ShoppingCart[1] crosses selectedProduct.inCart; }", "part with crosses")]
fn test_crosses_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// End Usage Tests (lines 1530-1600)
// ============================================================================

#[rstest]
#[case("item def T { end item cart: ShoppingCart[1] crosses selectedProduct.inCart; }", "end item usage")]
fn test_end_usage_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// More Expression Tests (lines 6400-6600)
// ============================================================================

#[rstest]
#[case("package T { attribute x = all TypeRef; }", "extent expression")]
fn test_extent_expression_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case("package T { attribute x = a.b; }", "feature chain expression")]
#[case("package T { attribute x = a.b.c; }", "longer feature chain")]
#[case("package T { attribute x = a[0]; }", "index expression")]
#[case("package T { attribute x = a[0..5]; }", "slice expression")]
fn test_chain_index_expression_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

#[rstest]
#[case("package T { attribute x = (a); }", "parenthesized expression")]
#[case("package T { attribute x = (a + b); }", "parenthesized binary")]
fn test_parenthesized_expression_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// New/Instantiation Expression Tests (lines 7800-7880)
// ============================================================================

#[rstest]
#[case("package T { attribute x = new MyType(); }", "new expression empty args")]
#[case("package T { attribute x = new MyType(a); }", "new expression with arg")]
#[case("package T { attribute x = new MyType(a, b); }", "new expression multiple args")]
fn test_instantiation_expression_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Collection Operation Tests (lines 7880-7950)
// ============================================================================

#[rstest]
#[case("package T { attribute x = items->select { in i; i > 0 }; }", "select expression")]
#[case("package T { attribute x = items->collect { in i; i * 2 }; }", "collect expression")]
#[case("package T { attribute x = items->forAll { in i; i > 0 }; }", "forAll expression")]
#[case("package T { attribute x = (1..5)->forAll { in i : Natural; i > 0 }; }", "range forAll")]
fn test_collection_operation_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// ForAll with Complex Bodies Tests (lines 7950-8100)
// ============================================================================

#[test]
fn test_forall_with_private_attribute() {
    let input = r#"package T { attribute x = (1..5)->forAll {
        in i : Natural;
        private attribute x = i * 2;
        x > 0
    }; }"#;
    assert_parses(input);
}

#[test]
fn test_forall_with_hash_access() {
    let input = r#"package T { attribute x = (1..numberOfBolts)->forAll {
        in i : Natural;
        private attribute lbcf = lugBolts#(i).coordinateFrame;
        lbcf == null
    }; }"#;
    assert_parses(input);
}

// ============================================================================
// Allocation Definition Tests (lines 8000-8100)
// ============================================================================

#[test]
fn test_allocation_def_with_end_features_detailed() {
    let input = r#"allocation def Logical_to_Physical :> A {
        end logical : Logical;
        end physical : Physical;
    }"#;
    assert_parses(input);
}

#[test]
fn test_nary_allocate_with_subsetting() {
    let input = "package T { allocate (logical ::> l, physical ::> p); }";
    assert_parses(input);
}

// ============================================================================
// Refinement Dependency Tests (lines 7900-8000)
// ============================================================================

#[test]
fn test_refinement_dependency_package() {
    let input = r#"package Engine4Cyl_Variant {
        public import ModelingMetadata::*;
        part engine:Engine {
            part cylinders:Cylinder[4..8] ordered;
        }
        part engine4Cyl :> engine {
            part redefines cylinders [4];
            part cylinder1 subsets cylinders[1];
        }
        #refinement dependency engine4Cyl to VehicleConfiguration_b::PartsTree::vehicle_b::engine;
    }"#;
    assert_parses(input);
}

// ============================================================================
// Analysis with Redefines Tests (lines 8150-8250)
// ============================================================================

#[test]
fn test_analysis_with_redefines() {
    let input = r#"analysis engineTradeOffAnalysis:TradeStudy {
        subject vehicleAlternatives[2] :> vehicle_b;
        part vehicle_b_engine4cyl :> vehicleAlternatives {
            part engine redefines engine {
                part cylinders :>> cylinders [4];
                attribute mass redefines mass = 180 [kg];
                attribute peakHorsePower redefines peakHorsePower = 180 [W];
            }
        }
    }"#;
    assert_parses(input);
}

// ============================================================================
// Portion Kind Tests (lines 580-620)
// ============================================================================

#[rstest]
#[case("package T { timeslice part x; }", "timeslice portion")]
#[case("package T { snapshot part x; }", "snapshot portion")]
fn test_portion_kind_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Requirement Constraint Kind Tests (lines 620-660)
// ============================================================================

#[rstest]
#[case("requirement def T { assume constraint x {} }", "assume constraint")]
#[case("requirement def T { require constraint x {} }", "require constraint")]
fn test_requirement_constraint_kind_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Message Flow Tests
// ============================================================================

#[rstest]
#[case("action def T { message msg eventA to eventB; }", "message with events")]
fn test_message_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Return Parameter Tests
// ============================================================================

#[rstest]
#[case("calc def T { return myValue; }", "return parameter")]
#[case("calc def T { return : Type; }", "typed return parameter")]
fn test_return_parameter_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Function Parameter List Tests (lines 8550-8650)
// ============================================================================

#[rstest]
#[case("calc def T (in a, out b, inout c) { }", "direction prefixes")]
#[case("calc def T (x, y, z) { }", "simple identifiers")]
fn test_function_parameter_list_variants(#[case] input: &str, #[case] _desc: &str) {
    assert_parses(input);
}

// ============================================================================
// Full Package Integration Tests
// ============================================================================

#[test]
fn test_full_vehicle_model_pattern() {
    let input = r#"package VehicleModel {
        import ISQ::*;
        
        part def Vehicle {
            part engine : Engine;
            part transmission : Transmission;
            port fuelCmdPort : FuelCmd;
        }
        
        part def Engine {
            attribute mass : Mass;
            port drivePwrPort : DrivePwr;
            port fuelInPort : FuelPort;
        }
        
        part vehicle : Vehicle {
            bind engine.fuelCmdPort = fuelCmdPort;
            interface engineInterface : EngineInterface
                connect engine.drivePwrPort to transmission.clutchPort;
        }
    }"#;
    assert_parses(input);
}

#[test]
fn test_full_requirements_pattern() {
    let input = r#"package RequirementsModel {
        requirement def SystemRequirement {
            subject system;
            require constraint { true }
        }
        
        requirement def SafetyRequirement :> SystemRequirement {
            stakeholder safetyEngineer;
            frame safetyConcern;
        }
        
        part system : System;
        
        satisfy requirement safetyReq : SafetyRequirement by system;
    }"#;
    assert_parses(input);
}

#[test]
fn test_full_state_machine_pattern() {
    let input = r#"state def OperatingStates {
        entry action initialize;
        
        state off;
        state on {
            entry action powerOn;
            do action monitor;
            exit action powerOff;
        }
        state error;
        
        transition initial then off;
        transition first off accept PowerOn then on;
        transition first on accept PowerOff then off;
        transition first on accept Fault then error;
    }"#;
    assert_parses(input);
}

#[test]
fn test_full_action_flow_pattern() {
    let input = r#"action def ProcessData {
        in data : DataPacket;
        out result : ProcessedData;
        
        action validate : ValidateData {
            in d = data;
            out valid;
        }
        
        action transform : TransformData {
            in d = data;
            out transformed;
        }
        
        action output : OutputResult {
            in t = transform.transformed;
            out r = result;
        }
        
        first validate then transform then output;
        
        flow from validate.valid to transform.d;
        flow from transform.transformed to output.t;
    }"#;
    assert_parses(input);
}
