# Complete Extracted Test Data from Archived Tests

This file contains ALL test input strings extracted programmatically.

Generated by extract_test_data.py

================================================================================


## tests_core_parse_result.rs.archived


*No SysML/KerML code samples found*


### Test Functions (27 total)
- test_is_ok_with_success
- test_is_ok_with_single_error
- test_is_ok_with_multiple_errors
- test_is_ok_with_empty_errors
- test_has_errors_with_no_errors
- test_has_errors_with_single_error
- test_has_errors_with_multiple_errors
- test_has_errors_with_empty_errors
- test_with_errors_empty_list
- test_with_errors_single_error
- test_with_errors_multiple_errors
- test_with_errors_content_is_none
- test_syntax_error_with_str
- test_syntax_error_with_string
- test_syntax_error_with_zero_position
- test_syntax_error_with_large_position
- test_syntax_error_with_empty_message
- test_syntax_error_into_conversion
- test_ast_error_with_str
- test_ast_error_with_string
- test_ast_error_with_zero_position
- test_ast_error_with_large_position
- test_ast_error_with_empty_message
- test_ast_error_into_conversion
- test_error_kind_difference
- test_parse_result_success_and_with_errors_difference
- test_multiple_error_types_mixed

## tests_kerml_examples.rs.archived


*No SysML/KerML code samples found*


### Test Functions (1 total)
- test_parse_all_kerml_examples

## tests_kerml_import_detection.rs.archived


### Code Samples (7 total)

- `classifier Vehicle { import Base::DataValue; }`
- `First member should be an Import`
- `classifier Vehicle { import all Base::DataValue; }`
- `classifier Vehicle { import Base::DataValue::*; }`
- `classifier Vehicle { import Base::DataValue::**; }`
- `classifier Vehicle { import Base::DataValue::*::**; }`
- `classifier Vehicle { import all Base::DataValue::**; }`

### Test Functions (6 total)
- test_import_normal
- test_import_all_recursive
- test_import_with_members_kind
- test_import_with_members_recursive_kind
- test_import_with_all_recursive_kind
- test_import_all_with_members_recursive

## tests_multiple_packages.rs.archived


### Code Samples (3 total)


#### Sample 1
```
package Vehicle;
        package Engine;
        package Transmission;
```

- `package SinglePackage;`
- `part myPart;`

### Test Functions (3 total)
- test_multiple_packages_in_single_file
- test_single_package
- test_no_packages

## tests_parser_expression_rowan.rs.archived


### Code Samples (56 total)


#### Sample 1
```
calc def Domain {
            in fn : SampledFunction;
            return : Anything[0..*] = fn.samples.domainValue;
        }
```


#### Sample 2
```
package T {
        assert constraint originalImpliesDerived {
            originalRequirement.result implies allTrue(derivedRequirements.result)
        }
    }
```


#### Sample 3
```
package T {
        assert constraint originalImpliesDerived {
            doc 
            /* comment */
            originalRequirement.result implies allTrue(derivedRequirements.result)
        }
    }
```


#### Sample 4
```
succession causalOrdering first [nCauses] causes.startShot then [nEffects] effects {
            doc /* test */
        }
```


#### Sample 5
```
package T {
        calc def Test {
            constraint assumptions[0..*] :> constraintChecks, subperformances { }
            constraint constraints[0..*] :> constraintChecks, subperformances { }
            return result = allTrue(assumptions()) implies allTrue(constraints()) { }
        }
    }
```


#### Sample 6
```
package T {
        calc def Test {
            doc
            /*
             * Some documentation
             */
            in x; eval(x)
        }
    }
```


#### Sample 7
```
package T {
        calc def Test {
            in ref a {
                doc
                /* The alternative */
            }
            a
        }
    }
```


#### Sample 8
```
package T {
        case def Test {
            doc
            /*
             * A TradeStudy documentation
             */
        }
    }
```

- `package T {{ attribute x = {}; }}`
- `package T {{ calc def Test {{ {} }} }}`
- `package T {{ constraint c {{ {} }} }}`
- `new SampledFunction(samples = values)`
- `list->select { in i; true }`
- `list->select { in i; true }#(1)`
- `list->select { in i : Positive; domainValues#(i) <= value }`
- `list->select { in i : Positive; domainValues#(i) <= value }#(1)`
- `(1..size(domainValues))->select { in i : Positive; domainValues#(i) <= value }#(1)`
- `domainValues->collect { in x; new SamplePair(x, calculation(x)) }`
- `attribute index : Positive[0..1] = (1..size(domainValues))->select { in i : Positive; domainValues#(i) <= value }#(1);`
- `attribute index = (1..size(domainValues))->select { in i : Positive; domainValues#(i) <= value }#(1);`
- `package Test { attribute index = list->select { in i : Positive; vals#(i) <= v }#(1); }`
- `attribute index : Positive[0..1];`
- `attribute x default foo { }`
- `attribute :>> x default foo { }`
- `attribute x[1] { }`
- `attribute x[1] default foo;`
- `attribute x[1] default foo { }`
- `attribute :>> x[1] { }`
- `attribute :>> x[1] default foo;`
- `attribute transformation[1] default nullTransformation { }`
- `attribute <x> myAttr;`
- `attribute <isq> 'International System of Quantities';`
- `attribute <isq> 'International System of Quantities': SystemOfQuantities { }`
- `attribute :>> dimensions = ();`
- `package T { attribute yocto { :>> conversionFactor = 1E-24; } }`
- `calc def Test { a == b }`
- `in fn : SampledFunction;`
- `return sampling = new SampledFunction();`
- `return result: StateSpace = value;`
- `constraint { stateSpace.order == order }`
- `package T { assert constraint c { in x = y; } }`
- `package T { assert constraint c { x implies f() } }`
- `value hastype Domain::ItemType`
- `myMetadata @@ SysML::Metadata`
- `package T { attribute pf { :>> quantity = isq.theta; } }`
- `package T { attribute pf { :>> quantity = isq.'z'; } }`
- `allTrue(derivedRequirements.result)`
- `originalRequirement.result implies allTrue(derivedRequirements.result)`
- `package T { part x[nCauses]; }`
- `package T { part x[0..size(items)]; }`
- `abstract interface interfaces: Interface[0..*] nonunique :> connections { }`
- `package T { abstract flow flows: Flow[0..*] nonunique :> messages, flowTransfers { } }`
- `package T { action def A { in whileTest default {true} { } } }`
- `package T { part def P { ref :>> outgoingTransfersFromSelf :> interfacingPorts.incomingTransfersToSelf { } } }`
- `package T { calc def Test { in p2 : Point; p1 != p2 } }`
- `package T { calc def Test { return a == b; } }`

### Test Functions (66 total)
- test_chained_member_access
- test_instantiation_expression_with_args
- test_instantiation_expression_positional
- test_arrow_invocation_with_block
- test_arrow_invocation_with_block_then_index
- test_typed_parameter_in_lambda
- test_typed_parameter_in_lambda_then_index
- test_full_sampled_functions_expression
- test_nested_instantiation_in_collect
- test_attribute_with_complex_initializer
- test_attribute_without_type
- test_attribute_in_package_context
- test_attribute_with_simple_type
- test_attribute_with_default_value_and_body
- test_attribute_with_redefinition_default_and_body
- test_attribute_with_multiplicity_and_body
- test_attribute_with_multiplicity_and_default
- test_attribute_with_multiplicity_default_no_redef_with_body
- test_attribute_with_redef_multiplicity_and_body
- test_attribute_with_redef_multiplicity_and_default
- test_attribute_with_long_name_multiplicity_default_body
- test_attribute_with_short_name
- test_attribute_with_short_name_and_quoted_full_name
- test_attribute_with_short_name_typed_and_body
- test_attribute_with_empty_tuple_value
- test_attribute_with_scientific_notation_value
- test_calculation_def_domain
- test_calculation_def_with_expression_body
- test_parameter_membership
- test_return_parameter_membership
- test_return_parameter_with_name
- test_return_parameter_with_name_and_type
- test_equality_expression_with_member_access
- test_complex_relational_expression
- test_constraint_usage_with_expression
- test_constraint_with_in_parameter
- test_constraint_with_function_call
- test_constraint_without_doc
- test_constraint_with_doc_and_expression
- test_as_expression_with_qualified_name
- test_hastype_with_qualified_name
- test_meta_expression_with_qualified_name
- test_metadata_access_with_qualified_name
- test_qualified_name_with_unicode_theta_simple
- test_qualified_name_with_unicode_theta_in_expression
- test_qualified_name_with_regular_identifiers_in_attribute_body
- test_qualified_name_with_quoted_name_in_attribute_body
- test_function_call_simple
- test_function_call_with_argument
- test_function_call_with_dotted_argument
- test_implies_expression_with_function_call
- test_invocation_expression_direct
- test_nested_function_call
- test_multiplicity_with_expression
- test_succession_with_multiplicity
- test_interface_usage_with_nonunique
- test_flow_usage_with_nonunique
- test_empty_tuple_expression
- test_in_parameter_with_default_block
- test_ref_with_feature_chain_subsetting
- test_invocation_in_calc_body_with_constraints
- test_expression_body_with_doc
- test_expression_body_with_ref_parameter
- test_expression_body_with_typed_parameter_no_direction
- test_all_true_as_identifier
- test_case_body_with_doc

## tests_parser_kerml_ast.rs.archived


### Code Samples (350 total)


#### Sample 1
```
classifier A;
        classifier B;
        classifier C;
```


#### Sample 2
```
package Test {
            import Base::*;
            classifier Vehicle;
            feature engine : Engine;
        }
```


#### Sample 3
```
standard library package ScalarValues {
        private import Base::DataValue;
        abstract datatype ScalarValue specializes DataValue;
        datatype Boolean specializes ScalarValue;
    }
```


#### Sample 4
```
classifier Vehicle {
    feature mass : Real;
    feature speed : Real;
}
```


#### Sample 5
```
class Car specializes Vehicle {
    feature engine : Engine;
}
```

- `classifier MyClassifier;`
- `MyClassifier`
- `abstract classifier Vehicle;`
- `class MyClass;`
- `MyClass`
- `abstract class Occurrence;`
- `Occurrence`
- `struct MyStruct;`
- `MyStruct`
- `datatype Real;`
- `datatype Boolean;`
- `behavior MyBehavior;`
- `MyBehavior`
- `function calculateArea;`
- `calculateArea`
- `function sum;`
- `predicate MyPredicate;`
- `MyPredicate`
- `interaction MyInteraction;`
- `MyInteraction`
- `metaclass MyMetaclass;`
- `MyMetaclass`
- `classifier Car specializes Vehicle;`
- `specializes`
- `classifier SportsCar :> Car;`
- `SportsCar`
- `class Occurrence specializes Anything;`
- `datatype ScalarValue specializes DataValue;`
- `abstract class Base :> Root;`
- `classifier Vehicle;`
- `abstract class Base;`
- `class Base;`
- `abstract datatype ScalarValue;`
- `Abstract mismatch for: {}`
- `function Test { in feature x; }`
- `function Test { out feature x; }`
- `function Test { inout feature x; }`
- `package Test { feature mass : Real; }`
- `package Test { feature x : Integer; }`
- `package Test { feature value : Boolean; }`
- `package Test { feature wheelMass subsets mass; }`
- `package Test { feature currentMass redefines mass; }`
- `package Test { feature x :> base; }`
- `package Test { feature y :>> original; }`
- `package Test { derived feature x; }`
- `package Test { feature x; }`
- `package MyPackage;`
- `MyPackage`
- `package Test {}`
- `package Nested { }`
- `library package MyLib;`
- `standard library package ScalarValues;`
- `standard library package Base;`
- `Standard mismatch for: {}`
- `import Base::*;`
- `import all Library::**;`
- `import MyPackage;`
- `classifier Vehicle { feature mass : Real; }`
- `class Car { feature engine : Engine; }`
- `struct Point { feature x : Real; }`
- `dependency Source to Target;`
- `dependency MyDep from Source to Target;`
- `dependency A, B to C, D;`
- `package Test { comment /* This is a comment */ }`
- `package Test { comment myComment /* text */ }`
- `type MyType;`
- `abstract type MyType {}`
- `type MyType ordered {}`
- `class MyClass {}`
- `abstract class MyClass;`
- `class MyClass specializes Base {}`
- `datatype MyData;`
- `datatype MyData {}`
- `abstract datatype ScalarValue specializes DataValue;`
- `struct MyStruct {}`
- `abstract struct MyStruct specializes Base {}`
- `assoc MyAssoc;`
- `assoc MyAssoc {}`
- `abstract assoc Link specializes Anything {}`
- `behavior MyBehavior {}`
- `abstract behavior Performance specializes Occurrence {}`
- `function MyFunction;`
- `function MyFunction {}`
- `function sum { in a: Integer; return : Integer; }`
- `predicate MyPredicate {}`
- `interaction MyInteraction {}`
- `metaclass MyMetaclass {}`
- `package Test { connector MyConnector; }`
- `package Test { connector MyConnector {} }`
- `package Test { binding MyBinding; }`
- `package Test { binding MyBinding {} }`
- `package Test { succession MySuccession; }`
- `package Test { succession MySuccession {} }`
- `package Test { step MyStep; }`
- `package Test { step MyStep {} }`
- `package Test { expr MyExpr; }`
- `package Test { expr MyExpr {} }`
- `package Test { feature MyFeature; }`
- `package Test { feature MyFeature {} }`
- `package Test { abstract feature MyFeature; }`
- `package Test { composite feature MyFeature; }`
- `package Test { portion feature MyFeature; }`
- `package Test { const feature MyFeature; }`
- `package Test { derived feature MyFeature; }`
- `package Test { end feature MyFeature; }`
- `package Test { feature MyFeature ordered; }`
- `package Test { feature MyFeature nonunique; }`
- `package Test { feature MyFeature ordered nonunique; }`
- `function Test { in feature MyFeature; }`
- `function Test { out feature MyFeature; }`
- `function Test { inout feature MyFeature; }`
- `public import MyLib;`
- `import all MyNamespace;`
- `private import all Base;`
- `import MyPackage::*;`
- `import MyPackage::**;`
- `namespace MyNamespace;`
- `namespace MyNamespace {}`
- `package MyPackage {}`
- `library package LibPkg;`
- `standard library package StdLib;`
- `package Test { feature elements[0..*] :>> Collection::elements {} }`
- `package Test { feature myFeature[1] :> BaseFeature; }`
- `package Test { feature items[*] : ItemType ordered; }`
- `package Test { feature dimensions: Positive[0..*] ordered nonunique { } }`
- `function test { in x: Integer[1]; }`
- `function test { out result: Boolean[1]; }`
- `function test { inout value: Real[0..*]; }`
- `function test { return : Integer[1]; }`
- `function test { return result: Natural[1]; }`
- `classifier A :> B;`
- `classifier A specializes B;`
- `package Test { feature x subsets y; }`
- `package Test { feature x redefines y; }`
- `package Test { feature x :>> y; }`
- `package Test { feature x ::> y; }`
- `Package should have multiple members`
- `Library should have members`
- `package Test { connector x to y; }`
- `package Test { connector from self to occ; }`
- `package Test { connector myConn: Type from a to b; }`
- `package Test { binding a = b; }`
- `package Test { binding x.y = z; }`
- `package Test { succession a then b; }`
- `package Test { first a then b; }`
- `package Test { flow myFlow from a to b; }`
- `package Test { flow a.y to b.x; }`
- `package Test { inv MyInvariant; }`
- `package Test { inv not MyInvariant {} }`
- `package Test { metadata MyType; }`
- `package Test { metadata myMeta : MyType; }`
- `package Test { metadata MyType about Foo; }`
- `package Test { feature x[1]; }`
- `package Test { feature x[0..1]; }`
- `package Test { feature x[0..*]; }`
- `package Test { feature x[*]; }`
- `package Test { feature x[1..*]; }`
- `package Test { feature x = 42; }`
- `package Test { feature x = true; }`
- `package Test { feature x = null; }`
- `package Test { feature rank: Natural[1] = size(dimensions); }`
- `abstract class Occurrence specializes Anything disjoint from DataValue {}`
- `package Test { disjoint a from b; }`
- `package Test { alias MyAlias for Target; }`
- `package Test { end feature x : MyType; }`
- `package Test { end feature y : BaseType[1]; }`
- `classifier A conjugates B;`
- `classifier A ~ B;`
- `type A unions B {}`
- `type A intersects B {}`
- `type A differences B {}`
- `package Test { feature chain chains source.target; }`
- `package Test { inverse B::g of A::f; }`
- `package Test { subset a.b subsets c.d; }`
- `assoc struct MyAssocStruct;`
- `assoc struct MyAssocStruct {}`
- `package Test { feature x = 3.14; }`
- `package Test { feature x = 1.5e10; }`
- `package Test { feature x = false; }`
- `package Test { feature x = *; }`
- `classifier A :> Foo;`
- `classifier A :> Foo::Bar;`
- `classifier A :> Foo::Bar::Baz;`
- `import Foo;`
- `import Foo::Bar;`
- `import Foo::Bar::Baz;`
- `package Test { feature x = a.b; }`
- `package Test { feature x = a.b.c; }`
- `package Test { feature x = a.b.c.d; }`
- `package Test { feature x = arr[0]; }`
- `package Test { feature x = matrix[1][2]; }`
- `classifier A :> BaseType;`
- `classifier A specializes BaseClass;`
- `classifier A :> Base1, Base2;`
- `classifier A :> Base1, Base2, Base3;`
- `package Test { feature x :> BaseType; }`
- `package Test { feature x subsets BaseClass; }`
- `package Test { feature x :> Base::MyType; }`
- `package Test { feature x :> Clock, Life; }`
- `package Test { feature x :> Type1, Type2, Type3; }`
- `package Test { feature x :>> BaseType; }`
- `package Test { feature x redefines OldFeature; }`
- `package Test { feature x :>> Base::Type; }`
- `package Test { feature x :>> Collection::elements; }`
- `package Test { feature x :>> Feature1, Feature2; }`
- `package Test { feature x ::> RefType; }`
- `package Test { feature x references RefFeature; }`
- `package Test { feature x ::> Ref::Feature; }`
- `package Test { feature x => CrossedType; }`
- `package Test { feature x crosses CrossedFeature; }`
- `package Test { feature x => Cross::Type; }`
- `classifier A conjugates BaseType;`
- `classifier A ~ ConjugateType;`
- `type A unions Type1 {}`
- `type A differences Type1 {}`
- `type A intersects Type1 {}`
- `type A intersects VectorValue, Array {}`
- `package Test { feature x chains feature1; }`
- `package Test { feature x chains source.target; }`
- `package Test { feature x chains a.b.c; }`
- `package Test { feature x chains parent.child; }`
- `class A disjoint from B {}`
- `package Test { disjoint Type1 from Type2; }`
- `package Test { inverse feature1 of feature2; }`
- `package Test { feature x featured by Type1; }`
- `package Test { featuring feature1 by Type1; }`
- `package Test { feature x : BaseType; }`
- `package Test { feature x typed by TypeSpec; }`
- `package Test { feature x : Complex; }`
- `package Test { feature x : Boolean, String; }`
- `package Test { feature x : Anything; }`
- `package Test { feature x : String, Integer; }`
- `package Test { subclassifier SubClass :> BaseClass; }`
- `package Test { subclassifier MyClass specializes ClassSpec; }`
- `package Test { feature x = MyRef; }`
- `package Test { feature x := MyRef; }`
- `package Test { feature x default MyRef; }`
- `private import MyLib;`
- `protected import MyLib;`
- `import MyImport::*;`
- `import MyImport::**;`
- `import MyImport::*::**;`
- `dependency Source, Other to Target, Dest;`
- `library package MyLib {}`
- `abstract class MyClass specializes Base, Other {}`
- `class all MyClass specializes Base;`
- `class MyClass[1] :> Base {}`
- `datatype Boolean specializes ScalarValue;`
- `datatype String specializes ScalarValue;`
- `struct MyStruct[1] :> Parent {}`
- `private struct MyStruct[0..1] specializes Base {}`
- `abstract struct MyStruct specializes Base, Other {}`
- `assoc MyAssoc specializes Base {}`
- `abstract behavior DecisionPerformance specializes Performance {}`
- `behavior MyBehavior specializes Base, Other {}`
- `function '==' {}`
- `function '!=' {}`
- `function '+' {}`
- `abstract function '-' {}`
- `package Test { connector a ::> a.x to b; }`
- `package Test { connector all from x to y; }`
- `function Test { in abstract const feature MyFeature ordered; }`
- `function Test { out composite derived feature MyFeature nonunique; }`
- `function Test { inout portion end feature MyFeature ordered nonunique; }`
- `package Test { comment /* simple comment */ }`
- `package Test { comment myComment /* comment text */ }`
- `package Test { comment about Foo /* about Foo */ }`
- `package Test { comment about Bar, Baz /* about multiple */ }`
- `package Test { doc /* documentation */ }`
- `package Test { doc MyDoc /* doc text */ }`
- `package Test { metadata myMeta : MyType about Foo, Bar; }`
- `package Test { flow myFlow; }`
- `package Test { succession flow; }`
- `package Test { succession flow myFlow; }`
- `function Test { in x: Anything[0..1]; }`
- `function Test { in y: Boolean[1]; }`
- `function Test { out result: Natural[1]; }`
- `function Test { inout value: Complex[0..*]; }`
- `function Test { in x: Anything[0..*] nonunique; }`
- `function Test { in x: Anything[0..*] ordered; }`
- `function Test { return : Boolean[1]; }`
- `function Test { return result: Natural[1]; }`
- `function Test { return : Complex[1] = x + y; }`
- `function '==' { in x: Anything[0..1]; in y: Anything[0..1]; return : Boolean[1]; }`
- `function add { in a: Natural[1]; in b: Natural[1]; return : Natural[1]; }`
- `function '-' {}`
- `function '*' {}`
- `function '/' {}`
- `function '<' {}`
- `function '>' {}`
- `function '<=' {}`
- `function '>=' {}`
- `function 'not' specializes ScalarFunctions::'not' {}`
- `function 'xor' specializes Base::'xor' {}`
- `package Test { feature r = x == y; }`
- `package Test { feature r = x != y; }`
- `package Test { feature r = x === y; }`
- `package Test { feature r = x < y; }`
- `package Test { feature r = x <= y; }`
- `package Test { feature r = x > y; }`
- `package Test { feature r = x >= y; }`
- `package Test { feature r = x + y; }`
- `package Test { feature r = x - y; }`
- `package Test { feature r = x * y; }`
- `package Test { feature r = x / y; }`
- `package Test { feature r = x and y; }`
- `package Test { feature r = x or y; }`
- `package Test { feature r = x xor y; }`
- `package Test { feature r = a == b and c == d; }`
- `package Test { feature r = x ?? 0; }`
- `function Test { in x: Integer[1] default 0; }`
- `function Test { in endIndex: Positive[1] default startIndex; }`
- `classifier <short> regular;`
- `classifier <shortName> MyClass;`
- `package <pkg> MyPackage {}`
- `classifier all MyClassifier {}`
- `type all x specializes A;`
- `classifier all C :> Base {}`
- `package Test { end [1] feature transferSource ::> source; }`
- `package Test { #Security feature z; }`
- `package Test { feature r = size(dimensions); }`
- `package Test { feature r = foo(); }`
- `package Test { feature r = max(a, b); }`
- `package Test { feature r = calculate(x, y, z); }`
- `package Test { feature r = rect(0.0, 1.0); }`
- `package Test { feature r = polar(1.0, 3.14); }`
- `package Test { feature r = sqrt(2.0); }`
- `package Test { feature r = if true ? 1 else 0; }`
- `package Test { feature r = if x > 5 ? yes else no; }`
- `package Test { feature r = col->size; }`
- `package Test { feature currentMass : Real redefines mass; }`
- `package Test { feature x : Type :>> original; }`
- `package Test { abstract flow flowTransfers: FlowTransfer[0..*] nonunique subsets transfers {} }`
- `package Test { feature r = x hastype T; }`
- `package Test { feature r = x istype T; }`
- `package Test { feature r = x @ T; }`
- `package Test { abstract step enactedPerformances: Performance[0..*] subsets performances, timeOccurrences {} }`
- `package Test { comment about Surface, Curve, Point /* body */ }`
- `package Test { feature r = a implies b; }`
- `package Test { derived var feature annotatedElement : Element[1..*] ordered redefines annotatedElement; }`
- `package Test { :>> dimension = size(components); }`
- `package Test { binding accept.receiver = triggerTarget; }`
- `package Test { connector :HappensDuring from [1] shorter references this to [1] longer references that; }`
- `package Test { locale "en_US" /* localized comment */ }`
- `class E :> $::Objects::Object;`

### Test Functions (3 total)
- test_multiple_definitions
- test_package_with_multiple_members
- test_standard_library_pattern

## tests_parser_kerml_pest.rs.archived


### Code Samples (361 total)


#### Sample 1
```
inv timeFlowConstraint {
        doc /* comment */
        snapshots->forAll{in s : Clock; TimeOf(s, thisClock) == s.currentTime}
    }
```


#### Sample 2
```
inv timeFlowConstraint {
        snapshots->forAll{in s : Clock; TimeOf(s, thisClock) == s.currentTime}
    }
```


#### Sample 3
```
{
        snapshots->forAll{in s : Clock; TimeOf(s, thisClock) == s.currentTime}
    }
```


#### Sample 4
```
{
        doc /* comment */
        snapshots->forAll{in s : Clock; TimeOf(s, thisClock) == s.currentTime}
    }
```


#### Sample 5
```
{
        doc /* comment */
        x
    }
```


#### Sample 6
```
{
        doc /* comment */
        x->y
    }
```


#### Sample 7
```
standard library package ScalarValues {
    private import Base::DataValue;
    abstract datatype ScalarValue specializes DataValue;
    datatype Boolean specializes ScalarValue;
}
```


#### Sample 8
```
package Test {
            const feature id : String;
        }
```


#### Sample 9
```
classifier Vehicle {
        feature mass : Real;
    }
```


#### Sample 10
```
end [0..1] feature x : X {
        @M;
    }
```

- `abstract`
- `alias`
- `assoc`
- `behavior`
- `class`
- `classifier`
- `comment`
- `datatype`
- `dependency`
- `disjoining`
- `disjoint`
- `feature`
- `featured`
- `flow`
- `function`
- `import`
- `interaction`
- `library`
- `metaclass`
- `metadata`
- `namespace`
- `package`
- `portion`
- `predicate`
- `redefines`
- `specializes`
- `standard`
- `struct`
- `subclassifier`
- `subsets`
- `succession`
- `// this is a comment`
- `/* block comment */`
- `Unknown classification test operator`
- `Unknown import kind`
- `This is a comment`
- `Ceci est un commentaire`
- `Documentation text`
- `{feature_ref:?}`
- `FeatureReference`
- `constfeature`
- `constfeature MyFeature;`
- `derivedfeature MyFeature;`
- `const feature MyFeature;`
- `derived feature MyFeature;`
- `const derived feature MyFeature;`
- `x.{in xx; xx + 1}`
- `x.?{in xx; xx != null}`
- `x->collect {in xx; xx + 1}`
- `x->select {in xx; xx != null}`
- `redefinition b.f redefines b.a;`
- `redefinition a :>> b;`
- `specialization id redefinition a.b redefines c.d { }`
- `subtype g.g specializes b.f.a;`
- `subtype A :> B;`
- `specialization id subtype A specializes B { }`
- `@Structure`
- `@@MetaClass`
- `class all JohnLife[0..1] specializes John;`
- `class MyClass[1] :> Base { }`
- `abstract #Classified z2;`
- `#Security feature z;`
- `private #Classified #Security feature z1;`
- `comment about Base::Vehicle /* Reference to qualified name */`
- `namespace MyNamespace;`
- `namespace MyNamespace {}`
- `package MyPackage;`
- `package Pkg1; package Pkg2;`
- `calculate(x, y, z)`
- `NumericalFunctions::sum0(x, y)`
- `Namespace::Nested::func(a)`
- `feature rank: Natural[1] = size(dimensions);`
- `feature x = 3;`
- `feature y = foo();`
- `feature i: Complex[1] = rect(0.0, 1.0);`
- `feature x: Real[1] = sqrt(2.0);`
- `feature x: Natural[1] = 42;`
- `function sum { in collection: Integer[0..*]; return : Integer[1] default sum0(collection, 0); }`
- `collection->select {in x; x > 0}`
- `coll->collect{in i : Positive; v#(i) + w#(i)}`
- `private thisClock : Clock :>> self;`
- `snapshots->forAll{in s : Clock; TimeOf(s, thisClock) == s.currentTime}`
- `abstract feature dataValues: DataValue[0..*] nonunique subsets things { }`
- `in indexes: Positive[n] ordered nonunique;`
- `derived var feature annotatedElement : Element[1..*] ordered redefines annotatedElement;`
- `:>> dimension = size(components);`
- `in redefines ifTest;`
- `succession [1] ifTest then [0..1] thenClause { }`
- `return resultValues : Anything [*] nonunique redefines result redefines values;`
- `protected expr monitoredOccurrence : Evaluation [1] redefines monitoredOccurrence { }`
- `in bool redefines onOccurrence { }`
- `protected bool redefines monitoredOccurrence[1] { }`
- `{in i; i > 0}`
- `in x y { }`
- `end feature thisThing: Anything redefines source subsets sameThing crosses sameThing.self;`
- `end self2 [1] feature sameThing: Anything redefines target subsets thisThing;`
- `abstract step enactedPerformances: Performance[0..*] subsets involvingPerformances, timeEnclosedOccurrences { }`
- `abstract class Occurrence specializes Anything disjoint from DataValue { }`
- `subset laterOccurrence.successors subsets earlierOccurrence.successors;`
- `bool guard[*] subsets enclosedPerformances;`
- `disjoint earlierOccurrence.successors from laterOccurrence.predecessors;`
- `connector :HappensDuring from [1] shorterOccurrence references thisOccurrence to [1] longerOccurrence references thatOccurrence;`
- `return feature changeSignal : ChangeSignal[1] = new ChangeSignal(condition, monitor) {}`
- `end [1] feature transferSource ::> source;`
- `abstract flow flowTransfers: FlowTransfer[0..*] nonunique subsets transfers {}`
- `end happensWhile [1..*] subsets timeCoincidentOccurrences feature thatOccurrence: Occurrence redefines longerOccurrence;`
- `{in s : Clock; TimeOf(s, thisClock) == s.currentTime}`
- `doc then simple expr failed: {:?}`
- `doc then arrow expr failed: {:?}`
- `classifier Car specializes Vehicle;`
- `Classifier should have 1 body member`
- `classifier SportsCar specializes Car, Vehicle;`
- `SportsCar`
- `feature mass : Real;`
- `Feature should have 1 body member`
- `feature currentMass redefines mass;`
- `feature wheelMass subsets mass;`
- `feature currentMass : Real redefines mass;`
- `Feature should have 2 body members`
- `abstract classifier Vehicle;`
- `Classifier should be abstract`
- `Package should have exactly one feature`
- `Feature should be const`
- `datatype Real;`
- `function calculateArea;`
- `calculateArea`
- `Classifier should have 1 nested feature`
- `Feature should have typing`
- `interface`
- `classification_test_operator`
- `import_kind`
- `myFeature`
- `feature_chain_expression`
- `import_prefix`
- `MyImport`
- `imported_reference`
- `MyImport::*`
- `MyImport::**`
- `MyImport::*::**`
- `:> BaseType`
- `:> public MyBase`
- `:> Base::MyType`
- `:> Clock, Life`
- `:> Type1, Type2, Type3`
- `:>> BaseType`
- `:>> Base::Type`
- `:>> Collection::elements`
- `:>> Feature1, Feature2`
- `::> RefType`
- `::> Ref::Feature`
- `feature_chaining`
- `inverse feature1 of feature2;`
- `feature_inverting`
- `inverse feature2 of other;`
- `featuring feature1 by Type1 ;`
- `feature_typing`
- `subclassifier SubClass :> BaseClass;`
- `subclassification`
- `subclassifier MyClass specializes ClassSpec;`
- `feature_value`
- `= alias Target`
- `feature_membership`
- `end_feature_membership`
- `import MyPackage;`
- `public import MyLib;`
- `import all MyNamespace;`
- `private import all Base;`
- `import MyPackage::*;`
- `import MyPackage::**;`
- `import MyPackage {}`
- `dependency Source to Target;`
- `dependency MyDep from Source to Target;`
- `dependency Source, Other to Target, Dest;`
- `dependency <short> named from Source to Target {}`
- `namespace <short> named {}`
- `package MyPackage {}`
- `package <short> named {}`
- `library package LibPkg;`
- `library_package`
- `standard library package StdLib;`
- `library package MyLib {}`
- `class MyClass;`
- `class MyClass {}`
- `abstract class MyClass;`
- `class MyClass specializes Base {}`
- `abstract class MyClass specializes Base, Other {}`
- `datatype MyData;`
- `datatype MyData {}`
- `abstract datatype ScalarValue specializes DataValue;`
- `datatype Boolean specializes ScalarValue;`
- `datatype String specializes ScalarValue;`
- `struct MyStruct;`
- `structure`
- `struct MyStruct {}`
- `struct MyStruct[1] :> Parent {}`
- `private struct MyStruct[0..1] specializes Base {}`
- `abstract struct MyStruct specializes Base, Other {}`
- `assoc MyAssoc;`
- `association`
- `assoc MyAssoc {}`
- `abstract assoc Link specializes Anything {}`
- `assoc MyAssoc specializes Base {}`
- `assoc struct MyAssocStruct;`
- `association_structure`
- `assoc struct MyAssocStruct {}`
- `behavior MyBehavior;`
- `behavior MyBehavior {}`
- `abstract behavior DecisionPerformance specializes Performance {}`
- `behavior MyBehavior specializes Base, Other {}`
- `function MyFunction;`
- `function MyFunction {}`
- `predicate MyPredicate;`
- `predicate MyPredicate {}`
- `interaction MyInteraction;`
- `interaction MyInteraction {}`
- `metaclass MyMetaclass;`
- `metaclass MyMetaclass {}`
- `succession MySuccession;`
- `succession MySuccession {}`
- `feature MyFeature;`
- `feature_basic`
- `feature MyFeature {}`
- `in feature MyFeature;`
- `feature_with_direction`
- `out feature MyFeature;`
- `inout feature MyFeature;`
- `abstract feature MyFeature;`
- `feature_with_composition`
- `composite feature MyFeature;`
- `portion feature MyFeature;`
- `feature_with_property`
- `end feature MyFeature;`
- `feature MyFeature ordered;`
- `feature_with_multiplicity_properties`
- `feature MyFeature nonunique;`
- `feature MyFeature ordered nonunique;`
- `in abstract const feature MyFeature ordered;`
- `feature_combined_modifiers`
- `out composite derived feature MyFeature nonunique;`
- `inout portion end feature MyFeature ordered nonunique;`
- `feature elements[0..*] :>> Collection::elements {}`
- `feature_with_multiplicity_and_relationships`
- `feature myFeature[1] :> BaseFeature;`
- `feature items[*] : ItemType ordered;`
- `comment_basic`
- `comment_with_about`
- `documentation_basic`
- `feature;`
- `feature myMultiplicity;`
- `feature myMultiplicity : MyType;`
- `feature myRange;`
- `feature myRange { feature bound; }`
- `metadata MyType;`
- `metadata_feature`
- `metadata myMeta : MyType;`
- `metadata MyType about Foo;`
- `metadata myMeta : MyType about Foo, Bar;`
- `item_feature`
- `feature myItem;`
- `feature myItem : ItemType;`
- `flow myFlow;`
- `item_flow`
- `flow myFlow from a to b;`
- `succession flow;`
- `succession_item_flow`
- `succession flow myFlow;`
- `fraction`
- `feature_reference`
- `Base::myFeature`
- `MyClassifier`
- `classifier_reference`
- `Base::MyClassifier`
- `type MyType;`
- `abstract type MyType {}`
- `type all MyType {}`
- `type MyType ordered {}`
- `type MyType unions BaseType {}`
- `type MyType differences BaseType {}`
- `classifier MyClassifier;`
- `abstract classifier MyClassifier {}`
- `classifier all MyClassifier {}`
- `classifier MyClassifier unions BaseClassifier {}`
- `obj.metadata`
- `metadata_access_expression`
- `Base::Feature.metadata`
- `feature dimensions: Positive[0..*] ordered nonunique { }`
- `feature_with_modifiers_after_typing`
- `feature x: Type ordered { }`
- `feature y: T nonunique { }`
- `feature z: T[1] ordered nonunique;`
- `documentation`
- `in x: Anything[0..1];`
- `in y: Boolean[1];`
- `out result: Natural[1];`
- `inout value: Complex[0..*];`
- `in x: Anything[0..*] nonunique;`
- `in x: Anything[0..*] ordered;`
- `function '==' { }`
- `function_with_operator_name`
- `function '!=' { }`
- `function '+' { }`
- `abstract function '-' { }`
- `function '=='{ in x: Anything[0..1]; in y: Anything[0..1]; return : Boolean[1]; }`
- `function_with_parameters`
- `function add { in a: Natural[1]; in b: Natural[1]; return : Natural[1]; }`
- `ScalarFunctions::'not'`
- `function 'not' specializes ScalarFunctions::'not' { }`
- `function_specializes_quoted`
- `function 'xor' specializes Base::'xor' { }`
- `in x: Integer[1] default 0;`
- `in endIndex: Positive[1] default startIndex;`
- `in expr thenValue[0..1] { return : Anything[0..*] ordered nonunique; }`
- `in step myStep { in x: Integer[1]; }`
- `specializes_operator`
- `redefines_operator`
- `subsets_operator`
- `feature chain chains source.target;`
- `feature_with_chaining`
- `private feature chain chains source.target;`
- `function '..' { in x: Integer[1]; return : Integer[1]; }`
- `function_with_range_operator`
- `function test { return : Integer[0..*]; }`
- `a ::> a.x`
- `connector a ::> a.x to b;`
- `connector myConn: Type from a to b;`
- `connector redefines fixWheel : Type [2] from [1] x to [1] y;`
- `flow a.y to b.x1;`
- `specialization Super subclassifier A specializes B;`
- `$::Root::Sub::Item`
- `class E :> $::Objects::Object;`
- `class E :> '$'::Objects::Object;`
- `connector drive featured by Car from engine to transmission;`
- `connector c featured by X from a to b { }`
- `connector featured by Y from x to y;`
- `member connector drive featured by Car from engine to transmission;`
- `type all x specializes A;`
- `type all x specializes A, B;`
- `classifier all C :> Base { }`
- `portion items: Item[*] nonunique;`
- `composite parts: Part[1..10] ordered nonunique;`
- `:> Base`
- `:>> original`
- `Package::Element`
- `:> A, B`
- `:> Base unions Other`
- `:> Base [1..*]`
- `[1..*] :> Base`
- `:> A, B [0..1] :> C`
- `myFeature :> Base`
- `myFeature [1..*]`
- `/* localized comment */`

### Test Functions (111 total)
- test_parse_kerml_identifier
- test_parse_kerml_line_comment
- test_parse_kerml_block_comment
- test_element_creation
- test_annotation_creation
- test_annotating_element_empty
- test_annotating_element_with_annotations
- test_textual_annotating_element
- test_comment_without_locale
- test_comment_with_locale
- test_documentation
- test_textual_representation
- test_clone_annotation
- test_equality_annotations
- test_relationship_with_element
- test_inheritance_from_relationship
- test_membership_with_alias
- test_import_with_flags
- test_element_reference_creation
- test_namespace_reference
- test_type_reference_hierarchy
- test_feature_reference
- test_parse_string_value
- test_parse_abstract_marker
- test_parse_const_modifier
- test_parse_sufficient
- test_parse_literal_string
- test_parse_literal_infinity
- test_parse_derived
- test_parse_end_marker
- test_parse_standard
- test_parse_import_all
- test_parse_block_comment
- test_parse_file_empty
- test_parse_file_with_whitespace
- test_annotation_reference_field_populated
- test_annotation_reference_with_qualified_name
- test_annotation_multiple_references
- test_annotation_span_captured
- test_parse_root_namespace_empty
- test_parse_root_namespace_with_package
- test_parse_root_namespace_with_multiple_elements
- test_parse_feature_with_typing_and_redefinition
- test_parse_lambda_parameter_no_semicolon
- test_parse_invariant_with_doc_and_expression
- test_parse_invariant_with_expression
- test_parse_implies_operator
- test_parse_invariant_with_implies
- test_parse_feature_with_multiplicity_props_before_subsetting
- test_parse_parameter_with_identifier_multiplicity
- test_parse_return_parameter_with_body
- test_parse_multiplicity_with_identification_and_bounds
- test_parse_feature_with_var_modifier
- test_parse_shorthand_feature_with_redefines_and_default
- test_parse_parameter_with_only_redefines
- test_parse_succession_with_multiplicity
- test_parse_binding_with_multiplicity_and_endpoints
- test_parse_binding_with_of_keyword
- test_parse_return_parameter_with_multiple_redefines
- test_parse_expression_with_visibility_and_typing
- test_parse_parameter_with_bool_type
- test_parse_parameter_with_multiplicity_props_after_type
- test_parse_typed_feature_member
- test_parse_lambda_with_inline_parameter
- test_parse_lambda_no_parameters
- test_parse_simple_parameter
- test_parse_cross_subsetting_with_feature_chain
- test_parse_end_feature_with_mult
- test_parse_step_with_multiple_subsets
- test_parse_comment_with_multiple_about
- test_parse_disjoining_with_from
- test_parse_subset_member
- test_parse_typed_feature_mult_before_relationships
- test_parse_binding_with_feature_chain
- test_parse_end_typed_feature
- test_parse_disjoint_feature_chains_from
- test_parse_connector_from_to_endpoints
- test_parse_return_feature_parameter
- test_parse_end_feature_mult_first
- test_parse_abstract_flow
- test_parse_istype_operator
- test_parse_end_feature_with_index_before_feature
- test_collect_args_with_in
- test_namespace_body_with_expression
- test_namespace_body_with_doc_and_expression
- test_annotating_member_doc
- test_two_namespace_elements
- test_doc_then_simple_expr
- test_doc_then_arrow_expr
- test_namespace_body_element_expression
- test_arrow_expr_as_element
- test_arrow_expr_in_body_no_doc
- test_elements_doc_then_arrow
- test_parse_scalar_values_stdlib_file
- test_parse_classifier_with_specialization_ast
- test_parse_classifier_with_multiple_specializations_ast
- test_parse_feature_with_typing_ast
- test_parse_feature_with_redefinition_ast
- test_parse_feature_with_subsetting_ast
- test_parse_feature_with_typing_and_redefinition_ast
- test_parse_abstract_classifier_ast
- test_parse_const_feature_ast
- test_parse_datatype_ast
- test_parse_function_ast
- test_parse_classifier_with_nested_feature_ast
- test_metadata_annotation_in_end_feature_body
- test_flow_with_feature_chains
- test_feature_with_multiple_types
- test_all_type_expression
- test_specialization_with_subclassifier
- test_locale_documentation

## tests_parser_kerml_span.rs.archived


### Code Samples (8 total)

- `standard`
- `library`
- `MyPackage`
- `package MyPackage;`
- `Package should have span`
- `MyLibrary`
- `library package MyLibrary;`
- `standard library package Base;`

### Test Functions (3 total)
- test_kerml_package_span_points_to_identifier
- test_kerml_library_package_span_points_to_identifier_not_library
- test_kerml_standard_library_package_span_points_to_identifier_not_standard

## tests_parser_sysml_ast.rs.archived


### Code Samples (642 total)


#### Sample 1
```
part def A;
        part def B;
        part def C;
```


#### Sample 2
```
package Test {
            import ISQ::*;
            part def Vehicle;
            part myPart : Vehicle;
        }
```


#### Sample 3
```
part def Vehicle {
        part engine : Engine;
        part wheels : Wheel[4];
    }
```


#### Sample 4
```
action def MyAction {
        action step1;
        action step2;
        first step1 then step2;
    }
```


#### Sample 5
```
standard library package ISQ {
        import SI::*;
        attribute def Length :> ScalarQuantityValue;
        attribute def Mass :> ScalarQuantityValue;
    }
```


#### Sample 6
```
package Test {
        part def Counter {
            attribute count : Integer := 0;
            action incr { assign count := count + 1; }
            action decr { assign count := count - 1; }
        }
        attribute def Incr;
        attribute def Decr;
    }
```


#### Sample 7
```
state def Counting {
        part counter : Counter;
        entry assign counter.count := 0;
        then state wait;
        accept Incr then increment;
        accept Decr then decrement;
        state increment { do assign counter.count := counter.count + 1; }
        then wait;
        state decrement { do assign counter.count := counter.count - 1; }
        then wait;
    }
```


#### Sample 8
```
calc def Increment {
        in c : Counter;
        return : Counter;
        perform c.incr;
        c
    }
```


#### Sample 9
```
action a {
        state counting : Counting;
        assign counting.counter.count := counting.counter.count + 1;
        assign counting.counter.count := Increment(counting.counter).count;
    }
```


#### Sample 10
```
action def DecisionTest {
        attribute x = 1;
        decide 'test x';
        if x == 1 then A1;
        if x > 1 then A2;
        else A3;
        then decide D;
        if true then A1;
        if false then A2;
        action A1;
        action A2;
        action A3;
        succession S first A1 if x == 0 then A2;
        first A3;
        if x > 0 then 'test x';
    }
```


#### Sample 11
```
package Test {
        occurrence def APIS_transfer_lifetime {
            interface APIS_transfer_interface : Interface connect (
                tlu ::> X.a,
                apsph ::> Y.b) {
                flow publish_returnallitems of Publish from apspm.pub to mqget.APIS_MQTT.pub;
                flow subscribe_returnallitems of Subscribe from apsc.subscr to mqgive.APIS_MQTT.subscr;
                flow call_getItems of CallGiveItems[1] from tlu.cll to apsph.cll;
            }
        }
    }
```


#### Sample 12
```
part vehicle {
        bind engine.fuelCmdPort = fuelCmdPort;
        interface engineInterface:EngineInterface connect engine.port1 to trans.port2;
        interface fuelInterface:FuelInterface connect fuelTank.outPort to engine.inPort;
    }
```


#### Sample 13
```
allocation def Logical_to_Physical :> A {
        end logical : Logical;
        end physical : Physical;
    }
```


#### Sample 14
```
package T { #derivation connection : Req1_Derivation {
        end r1 ::> req1;
        end r1_1 ::> req1_1;
        end r1_2 ::> req1_2;
    } }
```


#### Sample 15
```
verification massTests:MassTest {
        subject vehicle_uut :> vehicle_b;
        actor vehicleVerificationSubSystem_1 = verificationContext.massVerificationSystem;
        objective {
            verify vehicleSpecification.vehicleMassRequirement {
                redefines massActual = weighVehicle.massMeasured;
            }
        }
        action weighVehicle { out massMeasured:>ISQ::mass; }
        then action evaluatePassFail {
            in massMeasured:>ISQ::mass;
            out verdict = PassIf(vehicleSpecification.vehicleMassRequirement(vehicle_uut));
        }
        flow from weighVehicle.massMeasured to evaluatePassFail.massMeasured;
        return :>> verdict = evaluatePassFail.verdict;
    }
```


#### Sample 16
```
use case transportPassenger:TransportPassenger {
        first start;
        then action a { action driverGetInVehicle; }
        then action trigger accept ignitionCmd:IgnitionCmd;
        then action b { action driveVehicleToDestination; }
        then action c { action driverGetOutOfVehicle; }
        then done;
    }
```


#### Sample 17
```
package PartTest {
        part f: A;
        public part def A {
            part <'1'> b: B;
            protected port c: C;
            constant attribute x[0..2];
            derived constant ref attribute y :> x;
            ref z : Integer;
        }
    }
```

- `package T { comment locale "en-US" /* comment text */ }`
- `package T { comment MyComment locale "fr-FR" /* texte */ }`
- `package T { comment about Foo; }`
- `package T { comment about Foo, Bar; }`
- `package T { comment MyComment about Foo, Bar /* about multiple */ }`
- `package T { doc locale "en-US" /* docs */ }`
- `package T { doc MyDoc locale "ja-JP" /* text */ }`
- `package T { doc /* inline doc */ }`

#### Sample 26
```
package UpperLevelApprovals {
        public import DesignModel::**;
        filter @ApprovalMetadata::Approval and
            ApprovalMetadata::Approval::approved and
            ApprovalMetadata::Approval::level > 1;
    }
```


#### Sample 27
```
package UpperLevelApprovals {
        private import ApprovalMetadata::**;
        public import DesignModel::**[@Approval and approved and level > 1];
    }
```


#### Sample 28
```
abstract case def Case {
        subject subj : Anything[1] { }
        objective obj : RequirementCheck[1] {
            subject subj default Case::result;
        }
    }
```


#### Sample 29
```
case def Case {
        objective obj : RequirementCheck[1] {
            subject subj default Case::result;
        }
    }
```


#### Sample 30
```
part def T { abstract ref state exhibitedStates: StateAction[0..*] {
        doc /* StateActions that are exhibited by this Part. */
    } }
```


#### Sample 31
```
package T { assert constraint {
        doc /* Test constraint */
        innerSpaceDimension == value
    } }
```


#### Sample 32
```
package T { attribute x = (1..5)->forAll {
        in i : Natural;
        private attribute x = i * 2;
        x > 0
    }; }
```


#### Sample 33
```
package T { attribute x = (1..numberOfBolts)->forAll {
        in i : Natural;
        private attribute lbcf = lugBolts#(i).coordinateFrame;
        lbcf == null
    }; }
```


#### Sample 34
```
package Engine4Cyl_Variant {
        public import ModelingMetadata::*;
        part engine:Engine {
            part cylinders:Cylinder[4..8] ordered;
        }
        part engine4Cyl :> engine {
            part redefines cylinders [4];
            part cylinder1 subsets cylinders[1];
        }
        #refinement dependency engine4Cyl to VehicleConfiguration_b::PartsTree::vehicle_b::engine;
    }
```


#### Sample 35
```
analysis engineTradeOffAnalysis:TradeStudy {
        subject vehicleAlternatives[2] :> vehicle_b;
        part vehicle_b_engine4cyl :> vehicleAlternatives {
            part engine redefines engine {
                part cylinders :>> cylinders [4];
                attribute mass redefines mass = 180 [kg];
                attribute peakHorsePower redefines peakHorsePower = 180 [W];
            }
        }
    }
```


#### Sample 36
```
package VehicleModel {
        import ISQ::*;
        
        part def Vehicle {
            part engine : Engine;
            part transmission : Transmission;
            port fuelCmdPort : FuelCmd;
        }
        
        part def Engine {
            attribute mass : Mass;
            port drivePwrPort : DrivePwr;
            port fuelInPort : FuelPort;
        }
        
        part vehicle : Vehicle {
            bind engine.fuelCmdPort = fuelCmdPort;
            interface engineInterface : EngineInterface
                connect engine.drivePwrPort to transmission.clutchPort;
        }
    }
```


#### Sample 37
```
package RequirementsModel {
        requirement def SystemRequirement {
            subject system;
            require constraint { true }
        }
        
        requirement def SafetyRequirement :> SystemRequirement {
            stakeholder safetyEngineer;
            frame safetyConcern;
        }
        
        part system : System;
        
        satisfy requirement safetyReq : SafetyRequirement by system;
    }
```


#### Sample 38
```
state def OperatingStates {
        entry action initialize;
        
        state off;
        state on {
            entry action powerOn;
            do action monitor;
            exit action powerOff;
        }
        state error;
        
        transition initial then off;
        transition first off accept PowerOn then on;
        transition first on accept PowerOff then off;
        transition first on accept Fault then error;
    }
```


#### Sample 39
```
action def ProcessData {
        in data : DataPacket;
        out result : ProcessedData;
        
        action validate : ValidateData {
            in d = data;
            out valid;
        }
        
        action transform : TransformData {
            in d = data;
            out transformed;
        }
        
        action output : OutputResult {
            in t = transform.transformed;
            out r = result;
        }
        
        first validate then transform then output;
        
        flow from validate.valid to transform.d;
        flow from transform.transformed to output.t;
    }
```

- `part def MyPart;`
- `MyPart`
- `abstract part def Vehicle;`
- `attribute def MyAttr;`
- `port def MyPort;`
- `MyPort`
- `item def MyItem;`
- `MyItem`
- `action def MyAction;`
- `MyAction`
- `state def MyState;`
- `MyState`
- `constraint def MyConstraint;`
- `MyConstraint`
- `requirement def MyReq;`
- `case def MyCase;`
- `calc def MyCalc;`
- `MyCalc`
- `connection def MyConn;`
- `interface def MyInterface;`
- `MyInterface`
- `allocation def MyAlloc;`
- `flow def MyFlow;`
- `MyFlow`
- `view def MyView;`
- `MyView`
- `viewpoint def MyViewpoint;`
- `MyViewpoint`
- `rendering def MyRendering;`
- `MyRendering`
- `metadata def MyMetadata;`
- `MyMetadata`
- `occurrence def MyOccurrence;`
- `MyOccurrence`
- `enum def MyEnum;`
- `MyEnum`
- `analysis def MyAnalysis;`
- `verification def MyVerification;`
- `use case def MyUseCase;`
- `concern def MyConcern;`
- `package Test { part myPart; }`
- `myPart`
- `package Test { attribute myAttr; }`
- `package Test { port myPort; }`
- `myPort`
- `package Test { item myItem; }`
- `myItem`
- `package Test { action myAction; }`
- `myAction`
- `package Test { state myState; }`
- `myState`
- `package Test { constraint myConstraint; }`
- `myConstraint`
- `package Test { requirement myReq; }`
- `package Test { case myCase; }`
- `package Test { calc myCalc; }`
- `myCalc`
- `package Test { connection myConn; }`
- `package Test { interface myInterface; }`
- `myInterface`
- `package Test { allocation myAlloc; }`
- `package Test { flow myFlow; }`
- `myFlow`
- `package Test { view myView; }`
- `myView`
- `package Test { viewpoint myViewpoint; }`
- `myViewpoint`
- `package Test { rendering myRendering; }`
- `myRendering`
- `package Test { occurrence myOccurrence; }`
- `myOccurrence`
- `package Test { concern myConcern; }`
- `package Test { ref myRef; }`
- `part def Vehicle;`
- `abstract action def MyAction;`
- `Abstract mismatch for: {}`
- `variation part def VehicleChoices;`
- `action def Test { in item x; }`
- `action def Test { out item x; }`
- `action def Test { inout item x; }`
- `package Test { ref part myPart; }`
- `package Test { readonly part myPart; }`
- `package Test { derived attribute x; }`
- `package Test { attribute x; }`
- `package MyPackage;`
- `MyPackage`
- `package Test {}`
- `library package MyLib;`
- `standard library package ISQ;`
- `Standard mismatch for: {}`
- `import ISQ::*;`
- `import all Library::**;`
- `import MyPackage;`
- `part def Car :> Vehicle;`
- `part def Car specializes Vehicle;`
- `part def Vehicle { part engine; }`
- `part def Car { attribute speed : Real; }`
- `package MyPackage {}`
- `library package MyLibrary;`
- `standard library package MyLibrary;`
- `package Pkg1; package Pkg2;`
- `part def MyPart {}`
- `abstract part def MyPart;`
- `variation part def MyPart;`
- `part def MyPart :> Base;`
- `part def MyPart :> Base {}`
- `attribute def MyAttr {}`
- `port def MyPort {}`
- `port def ~MyConjugatedPort;`
- `item def MyItem {}`
- `action def MyAction {}`
- `state def MyState {}`
- `constraint def MyConstraint {}`
- `requirement def MyReq {}`
- `case def MyCase {}`
- `calc def MyCalc {}`
- `connection def MyConn {}`
- `interface def MyInterface {}`
- `allocation def MyAlloc {}`
- `flow def MyFlow {}`
- `view def MyView {}`
- `viewpoint def MyViewpoint {}`
- `rendering def MyRendering {}`
- `abstract metadata def MyMetadata;`
- `occurrence def MyOccurrence {}`
- `enum def MyEnum {}`
- `analysis def MyAnalysis {}`
- `verification def MyVerification {}`
- `use case def MyUseCase {}`
- `concern def MyConcern {}`
- `individual def MyIndividual;`
- `individual def MyIndividual {}`
- `package Test { part myPart {} }`
- `package Test { abstract part myPart; }`
- `package Test { attribute myAttr : Real; }`
- `package Test { derived attribute myAttr; }`
- `package Test { port myPort : ~PortType; }`
- `package Test { end item myItem; }`
- `package Test { action myAction {} }`
- `package Test { ref state myState; }`
- `package Test { assert constraint {} }`
- `package Test { satisfy requirement; }`
- `package Test { connect a to b; }`
- `package Test { allocate a to b; }`
- `package Test { flow myFlow from a to b; }`
- `package Test { render myRendering; }`
- `package Test { ref myRef {} }`
- `action def Test { fork; }`
- `action def Test { fork myFork; }`
- `action def Test { merge; }`
- `action def Test { merge myMerge; }`
- `action def Test { join; }`
- `action def Test { join myJoin; }`
- `action def Test { decide; }`
- `action def Test { decide myDecision; }`
- `state def Test { entry myEntryAction; }`
- `state def Test { exit myExitAction; }`
- `state def Test { do myDoAction; }`
- `state def Test { transition first a then b; }`
- `package Test { first source then target; }`
- `package Test { succession mySuccession first source then target; }`
- `requirement def Test { subject mySubject; }`
- `requirement def Test { actor myActor; }`
- `requirement def Test { stakeholder myStakeholder; }`
- `requirement def Test { require myConstraint; }`
- `requirement def Test { assume myConstraint; }`
- `requirement def Test { frame myConcern; }`
- `requirement def Test { verify myVerification; }`
- `case def Test { objective myObj; }`
- `package Test { expose MyElement; }`
- `part def Test { variant myVariant; }`
- `action def Test { terminate myOccurrence; }`
- `dependency from A to B;`
- `dependency A to B;`
- `dependency myDep from A to B;`
- `dependency from A, B to C, D;`
- `dependency from A to B {}`
- `package Test { comment /* text */ }`
- `package Test { comment MyComment /* text */ }`
- `package Test { comment about Foo /* text */ }`
- `package Test { comment about Foo, Bar /* text */ }`
- `package Test { doc /* documentation */ }`
- `package Test { doc MyDoc /* text */ }`
- `package Test { #MyMetadata }`
- `package Test { metadata MyMetadata; }`
- `package Test { @MyMetadata; }`
- `package Test { metadata MyMetadata about A, B; }`
- `package Test { metadata myMeta : MyMetadata; }`
- `package Test { metadata MyMetadata {} }`
- `import MyElement;`
- `public import MyElement;`
- `import all MyElement;`
- `import MyElement::*;`
- `import MyElement::**;`
- `import MyElement::*::**;`
- `import MyElement {}`
- `package Test { alias MyAlias for MyElement; }`
- `package Test { private alias MyAlias for MyElement; }`
- `package Test { bind source = target; }`
- `package Test { connection myConn connect a to b; }`
- `package Test { attribute x = 42; }`
- `package Test { attribute x := 42; }`
- `package Test { attribute x default 42; }`
- `package Test { attribute x default = 42; }`
- `package Test { part x : Type; }`
- `package Test { part x : Type[1]; }`
- `package Test { part x : Type[0..*]; }`
- `package Test { part x : Type[*]; }`
- `package Test { part x[1..*] : Type; }`
- `package Test { part x[0..*] ordered; }`
- `package Test { part x[0..*] nonunique; }`
- `package Test { part x[0..*] ordered nonunique; }`
- `part def A :> B;`
- `part def A specializes B;`
- `part def A :> B, C;`
- `package Test { part a subsets b; }`
- `package Test { part a redefines b; }`
- `package Test { part a :>> b; }`
- `package Test { part a references b; }`
- `package Test { part a ::> b; }`
- `package Test { attribute x = a + b; }`
- `package Test { attribute x = a - b; }`
- `package Test { attribute x = a * b; }`
- `package Test { attribute x = a / b; }`
- `package Test { attribute x = a == b; }`
- `package Test { attribute x = a != b; }`
- `package Test { attribute x = a < b; }`
- `package Test { attribute x = a > b; }`
- `package Test { attribute x = a and b; }`
- `package Test { attribute x = a or b; }`
- `package Test { attribute x = a xor b; }`
- `package Test { attribute x = a implies b; }`
- `package Test { attribute x = if a ? b else c; }`
- `package Test { attribute x = a ?? b; }`
- `package Test { attribute x = foo(); }`
- `package Test { attribute x = foo(a); }`
- `package Test { attribute x = foo(a, b); }`
- `package Test { attribute x = Pkg::foo(); }`
- `action def Test { send msg to target; }`
- `action def Test { accept msg; }`
- `action def Test { accept msg via channel; }`
- `action def Test { perform myAction; }`
- `action def Test { if cond then a; }`
- `action def Test { if cond then a else b; }`
- `action def Test { while cond loop body; }`
- `action def Test { loop body until cond; }`
- `action def Test { for x : Type in items loop body; }`
- `action def Test { assign x := value; }`
- `Package should have multiple members`
- `part def MyPart { }`
- `individual part def UniquePart;`
- `variation part def PartVariants;`
- `part def MyPart :> Base, Other;`
- `package T { part myPart; }`
- `package T { part myPart { } }`
- `package T { ref individual part uniquePart; }`
- `package T { snapshot part snap1; }`
- `package T { timeslice part slice1; }`
- `port def MyPort { }`
- `port def ~ConjugatedPort;`
- `package T { port myPort; }`
- `package T { port myPort { } }`
- `package T { port drive: ~DriveIF; }`
- `package T { ref individual port uniquePort; }`
- `package T { snapshot port snap1; }`
- `package T { bind source = target; }`
- `package T { bind source = target { } }`
- `package T { binding myBinding bind source = target; }`
- `package T { connect a to b; }`
- `package T { connect (a, b, c); }`
- `package T { connection myConn connect a to b; }`
- `connection def MyConnection;`
- `connection def MyConnection { }`
- `abstract connection def MyConnection;`
- `package T { connection myConn; }`
- `package T { connection myConn { } }`
- `package T { connect source to target; }`
- `package T { connection myConn connect source to target; }`
- `interface def Vehicle { port driver; }`
- `abstract interface def DataInterface { ref data : DataType; }`
- `interface def FuelingInterface { end fuelOutPort : FuelingPort; end fuelInPort : ~FuelingPort; }`
- `package T { interface connect left to right; }`
- `package T { interface connect left to right{} }`
- `package T { interface leftFrontMount: Mounting connect frontAxle.leftMountingPoint to leftFrontWheel.hub; }`
- `package T { interface driveShaft connect transDrive ::> transmission.drive to axleDrive ::> rearAxle.drive; }`
- `flow def DataFlow;`
- `flow def FluidFlow { }`
- `abstract flow def AbstractFlow;`
- `package T { flow myFlow; }`
- `package T { flow a to b; }`
- `package T { flow a.b to c.d; }`
- `package T { flow b.f.a to c.aa; }`
- `package T { flow of Exposure from focus.xrsl to shoot.xsf; }`
- `package T { flow publish of Publish from a.b to c.d; }`
- `package T { succession flow x.p to a.b; }`
- `package T { succession flow a to b; }`
- `action def Move;`
- `action def Calculate { }`
- `abstract action def AbstractAction;`
- `action def Process (in data, out result) { }`
- `action def Drive :> Action;`
- `package T { action myAction; }`
- `package T { action myAction { } }`
- `package T { action doSomething; }`
- `action def T { first start; then merge m; }`
- `action def T { first start; then decide d; }`
- `action def T { first A1 then A2; }`
- `action def T { succession S first A1 then A2; }`
- `action def T { first A1 if x == 0 then A2; }`
- `action def T { first A1 else A2; }`
- `package T { perform c.incr; }`
- `package T { perform myAction; }`
- `action def T { accept msg; }`
- `action def T { accept S; }`
- `action def T { accept signal : SignalType; }`
- `action def T { accept sig after 10; }`
- `action def T { accept at timeValue; }`
- `action def T { accept when condition; }`
- `action def T { send msg to target; }`
- `action def T { send msg via port; }`
- `action def T { send msg via port to target; }`
- `action def T { assign x := y; }`
- `action def T { assign count := count + 1; }`
- `action def T { assign counter.count := 0; }`
- `action def T { assign counter.count := counter.count + 1; }`
- `action def T { if condition {} }`
- `action def T { if x {} else {} }`
- `action def T { while condition {} }`
- `action def T { loop {} }`
- `action def T { loop {} until result; }`
- `action def T { for x in items {} }`
- `action def T { terminate; }`
- `state def MyState parallel {}`
- `abstract state def MyState;`
- `package T { state myState; }`
- `package T { state myState {} }`
- `package T { state myState parallel {} }`
- `package T { exhibit state myState; }`
- `state def T { entry action entryAction; }`
- `state def T { entry; }`
- `state def T { entry setupSensor; }`
- `state def T { do action doAction; }`
- `state def T { do; }`
- `state def T { do monitorTemperature; }`
- `state def T { exit action exitAction; }`
- `state def T { exit; }`
- `state def T { exit cleanup; }`
- `state def T { transition first S1 then S2; }`
- `state def T { transition T first S1 then S2; }`
- `state def T { transition initial then off; }`
- `package T { allocate a to b; }`
- `package T { allocate l.component to assembly.element; }`
- `package T { allocation myAlloc; }`
- `package T { allocation allocation1 : Logical_to_Physical allocate l to p; }`
- `calc def Increment { in c : Counter; return : Counter; perform c.incr; c }`
- `calc def Torque (current:>SI::A, voltage:>ISQ::voltage):> ISQ::torque { }`
- `package T { calc myCalc; }`
- `package T { calc myCalc {} }`
- `package T { constraint myConstraint; }`
- `package T { constraint myConstraint {} }`
- `package T { assert constraint {} }`
- `package T { assert myRef; }`
- `package T { assert not myRef; }`
- `requirement def SafetyRequirement;`
- `requirement def SafetyRequirement {}`
- `requirement def <'REQ-1'> SafetyReq { }`
- `package T { requirement myReq; }`
- `package T { satisfy requirement; }`
- `package T { satisfy Requirements::REQ1 by RoboticVacuumCleaner::battery; }`
- `package T { satisfy req by system.component.feature; }`
- `package T { assert satisfy r by q; }`
- `package T { assert not satisfy r1 by q; }`
- `requirement def T { subject mySubject; }`
- `requirement def T { subject subj : MyType; }`
- `requirement def T { subject subj default myValue; }`
- `requirement def T { actor myActor; }`
- `requirement def T { stakeholder myStakeholder; }`
- `requirement def T { assume myConstraint {} }`
- `requirement def T { require constraint {} }`
- `requirement def T { frame myConcern; }`
- `requirement def T { verify myVerification; }`
- `concern def PerformanceConcern;`
- `concern def PerformanceConcern {}`
- `concern def SafetyConcern { subject vehicle; stakeholder driver; }`
- `package T { concern myConcern {} }`
- `case def TestCase;`
- `case def TestCase {}`
- `case def TestCase { subject testSubject; }`
- `package T { case testCase; }`
- `package T { case testCase {} }`
- `package T { case testCase { subject testSubject; } }`
- `case def T { objective myObjective {} }`
- `analysis def AnalysisTest;`
- `analysis def AnalysisTest {}`
- `analysis def AnalysisTest { subject testSubject; }`
- `package T { analysis testAnalysis; }`
- `package T { analysis testAnalysis {} }`
- `package T { analysis testAnalysis { actor analyst; } }`
- `verification def VerifyTest;`
- `verification def VerifyTest {}`
- `verification def VerifyTest { objective myObj {} }`
- `package T { verification testVerification; }`
- `package T { verification testVerification {} }`
- `use case def TestUseCase;`
- `use case def TestUseCase {}`
- `package T { use case transportPassenger:TransportPassenger; }`
- `package T { include use case uc1 : UC1; }`
- `package T { include uc2; }`
- `view def TestView;`
- `view def TestView {}`
- `package T { view myView; }`
- `package T { view myView {} }`
- `package T { render myRendering; }`
- `viewpoint def TestViewpoint;`
- `viewpoint def TestViewpoint {}`
- `viewpoint def TestViewpoint { stakeholder user; }`
- `package T { viewpoint myViewpoint; }`
- `package T { viewpoint myViewpoint {} }`
- `rendering def TestRendering;`
- `rendering def TestRendering {}`
- `package T { rendering myRendering; }`
- `package T { attribute x = myValue; }`
- `package T { attribute x = "test"; }`
- `package T { attribute x = 123; }`
- `package T { attribute x = false; }`
- `package T { attribute x = if a ? b else c; }`
- `package T { attribute x = a ?? b; }`
- `package T { attribute x = a implies b; }`
- `package T { attribute x = a | b; }`
- `package T { attribute x = a or b; }`
- `package T { attribute x = a xor b; }`
- `package T { attribute x = a & b; }`
- `package T { attribute x = a and b; }`
- `package T { attribute x = a == b; }`
- `package T { attribute x = a != b; }`
- `package T { attribute x = a === b; }`
- `package T { attribute x = a !== b; }`
- `package T { attribute x = value hastype Type; }`
- `package T { attribute x = value istype Type; }`
- `package T { attribute x = value @ Type; }`
- `@ classification`
- `package T { attribute x = value as Type; }`
- `package T { attribute x = a < b; }`
- `package T { attribute x = a > b; }`
- `package T { attribute x = a <= b; }`
- `package T { attribute x = a >= b; }`
- `package T { attribute x = 1..10; }`
- `package T { attribute x = a + b; }`
- `package T { attribute x = a - b; }`
- `subtraction`
- `package T { attribute x = a + b - c; }`
- `package T { attribute x = a * b; }`
- `package T { attribute x = a / b; }`
- `package T { attribute x = a % b; }`
- `package T { attribute x = a ** b; }`
- `package T { attribute x = a ^ b; }`
- `package T { attribute x = +value; }`
- `package T { attribute x = -value; }`
- `package T { attribute x = ~value; }`
- `package T { attribute x = not value; }`
- `package T { attribute x = "hello world"; }`
- `package T { attribute x = ""; }`
- `package T { attribute x = 42; }`
- `package T { attribute x = -42; }`
- `package T { attribute x = 3.14; }`
- `package T { attribute x = -3.14; }`
- `package T { attribute x = true; }`
- `package T { attribute x = null; }`
- `package T { attribute x = foo(); }`
- `package T { attribute x = foo(arg); }`
- `package T { attribute x = foo(arg1, arg2); }`
- `package T { attribute x = foo(arg1, arg2, arg3); }`
- `package T { attribute x = foo(param1 = value1); }`
- `package T { attribute x = foo(param1 = value1, param2 = value2); }`
- `package T { attribute x = MyType(); }`
- `package T { attribute x = MyType(arg); }`
- `package T { attribute x = MyType(arg1, arg2); }`
- `package T { attribute x = MyType(param = value); }`
- `package T { attribute x = foo.bar(x); }`
- `package T { attribute x = PassIf(spec.req(uut)); }`
- `package T { attribute x = 5 [kg]; }`
- `package T { attribute x = 120.5 [min]; }`
- `package T { attribute x = 0 [SI::m]; }`
- `import q;`
- `import myPackage;`
- `import A::B;`
- `import A::B::C;`
- `import q::**;`
- `import myPackage::**;`
- `import A::B::**;`
- `import q::*;`
- `import myPackage::*;`
- `import A::B::*;`
- `package T { expose MyNamespace::*; }`
- `package T { expose A::B::*; }`
- `package T { expose MyPackage::*::**; }`
- `package T { expose MyElement; }`
- `package T { expose A::B::C; }`
- `action def T { language "ocl" /* code */ }`
- `action def T { rep language "ocl" /* code */ }`
- `action def T { rep inOCL language "ocl" /* code */ }`
- `package T { attribute :>> localClock.currentTime; }`
- `package T { attribute :>> localClock.currentTime = startTime + elapseTime; }`
- `package T { part cylinders :>> cylinders [4]; }`
- `package T { attribute mass redefines mass = 180 [kg]; }`
- `variation part def V :> P { variant part x : Q { attribute b : B; } }`
- `package T { variation part v : P { variant q { attribute b : B; } } }`
- `#refinement dependency engine4Cyl to VehicleConfiguration::PartsTree::vehicle::engine;`
- `package T { @Rationale { text = "reasoning"; } }`
- `package T { @Rationale about myElement { text = "reasoning"; } }`
- `part def A { part <'1'> b: B; }`
- `part def <myId> Test;`
- `attribute def MyAttribute;`
- `allocation def MyAllocation;`
- `requirement def MyRequirement;`
- `analysis def MyAnalysisCase;`
- `verification def MyVerificationCase;`
- `part def A :> Base;`
- `part def A specializes Base;`
- `part def A :> Base1, Base2;`
- `part def A :> Base1, Base2, Base3;`
- `package T { part x[1]; }`
- `package T { part x[0..*]; }`
- `package T { part x[1..5]; }`
- `package T { part x[*]; }`
- `package T { part x[1] ordered; }`
- `package T { part x[*] nonunique; }`
- `package T { part x[0..*] ordered nonunique; }`
- `package T { part x : BaseType; }`
- `package T { part x :> BaseFeature; }`
- `subsets`
- `package T { part x ::> ReferencedFeature; }`
- `package T { part x :>> RedefinedFeature; }`
- `redefines`
- `package T { part x subsets BaseFeature; }`
- `package T { part x redefines BaseFeature; }`
- `package T { part x references BaseFeature; }`
- `package T { part x :> a.b; }`
- `package T { part x :> a.b.c; }`
- `package T { part x :> vehicle.engine.cylinder; }`
- `part def A;`
- `part def A { }`
- `part def A { part b; }`
- `part def A { part b; part c; }`
- `package T { constant part x; }`
- `package T { derived part x; }`
- `package T { constant derived part x; }`
- `package T { readonly part x; }`
- `action def T { in part x; }`
- `action def T { out part x; }`
- `action def T { inout part x; }`
- `package T { attribute x := 42; }`
- `package T { attribute x default 42; }`
- `package T { attribute x default = 42; }`
- `public part def A;`
- `private part def A;`
- `protected part def A;`
- `package T { public part x; }`
- `package T { private part x; }`
- `package T { protected part x; }`
- `package T { comment locale`
- `/* comment text */ }`
- `package T { comment MyComment locale`
- `package T { doc locale`
- `/* docs */ }`
- `package T { doc MyDoc locale`
- `package T { #MyMetadata }`
- `package T { metadata MyMetadata; }`
- `package T { @MyMetadata; }`
- `package T { metadata MyMetadata about A, B; }`
- `package T { metadata myMeta : MyMetadata; }`
- `package T { metadata MyMetadata { } }`
- `import MyElement [condition];`
- `import MyElement [filter1][filter2];`
- `import MyElement { }`
- `package T { ref state myState; }`
- `part def T { abstract ref state exhibitedStates: StateAction[0..*] { } }`
- `package T { part cart: ShoppingCart[1] crosses selectedProduct.inCart; }`
- `item def T { end item cart: ShoppingCart[1] crosses selectedProduct.inCart; }`
- `package T { attribute x = all TypeRef; }`
- `package T { attribute x = a.b; }`
- `package T { attribute x = a.b.c; }`
- `package T { attribute x = a[0]; }`
- `package T { attribute x = a[0..5]; }`
- `package T { attribute x = (a); }`
- `package T { attribute x = (a + b); }`
- `package T { attribute x = new MyType(); }`
- `package T { attribute x = new MyType(a); }`
- `package T { attribute x = new MyType(a, b); }`
- `package T { attribute x = items->select { in i; i > 0 }; }`
- `package T { attribute x = items->collect { in i; i * 2 }; }`
- `package T { attribute x = items->forAll { in i; i > 0 }; }`
- `package T { attribute x = (1..5)->forAll { in i : Natural; i > 0 }; }`
- `package T { allocate (logical ::> l, physical ::> p); }`
- `package T { timeslice part x; }`
- `package T { snapshot part x; }`
- `requirement def T { assume constraint x {} }`
- `requirement def T { require constraint x {} }`
- `action def T { message msg eventA to eventB; }`
- `calc def T { return myValue; }`
- `calc def T { return : Type; }`
- `calc def T (in a, out b, inout c) { }`
- `calc def T (x, y, z) { }`

### Test Functions (35 total)
- test_multiple_definitions
- test_package_with_multiple_members
- test_part_with_nested_parts
- test_action_with_control_flow
- test_standard_library_pattern
- test_complex_package_with_parts
- test_state_def_with_entry_and_do_assignments
- test_calc_def_with_perform
- test_action_with_state_and_assignments
- test_decision_test_action_def
- test_interface_usage_with_flows
- test_part_with_bind_and_interfaces
- test_allocation_def_with_end_features
- test_derivation_connection_with_end_elements
- test_verification_with_actions
- test_use_case_with_trigger_accept
- test_part_test_file_pattern
- test_package_with_filter_statement
- test_package_with_filtered_import
- test_cases_sysml_fragment
- test_simplified_case_with_objective
- test_ref_state_usage
- test_abstract_ref_state_usage
- test_state_with_doc_comment
- test_constraint_with_doc_comment
- test_forall_with_private_attribute
- test_forall_with_hash_access
- test_allocation_def_with_end_features_detailed
- test_nary_allocate_with_subsetting
- test_refinement_dependency_package
- test_analysis_with_redefines
- test_full_vehicle_model_pattern
- test_full_requirements_pattern
- test_full_state_machine_pattern
- test_full_action_flow_pattern

## tests_parser_sysml_pest.rs.archived


### Code Samples (491 total)

- `comment about Foo;`
- `comment about Foo, Bar;`
- `comment locale "en-US" about Foo;`
- `doc;`

#### Sample 5
```
abstract case def Case {
                subject subj : Anything[1] { }
                objective obj : RequirementCheck[1] {
                        subject subj default Case::result;
                }
        }
```


#### Sample 6
```
case def Case {
    objective obj : RequirementCheck[1] {
        subject subj default Case::result;
    }
}
```


#### Sample 7
```
objective obj : RequirementCheck[1] {
        subject subj default Case::result;
    }
```


#### Sample 8
```
{
    objective obj : RequirementCheck[1] {
        subject subj default Case::result;
    }
}
```


#### Sample 9
```
abstract ref state exhibitedStates: StateAction[0..*] {
        doc
        /*
         * StateActions that are exhibited by this Part.
         */
    }
```


#### Sample 10
```
assert constraint {
        doc
        /*
         * Test constraint
         */
        innerSpaceDimension == value
    }
```

- `public import DesignModel::**[@Approval and approved and level > 1];`
- `import DesignModel::**[@PartDefinition and @PartDefinition::ownedPart != null];`
- `import X::*[@A][@B][@C];`
- `private import ApprovalMetadata::**;`
- `import Pkg::Element[@isAbstract];`

#### Sample 16
```
package UpperLevelApprovals {
    public import DesignModel::**;
    filter @ApprovalMetadata::Approval and
        ApprovalMetadata::Approval::approved and
        ApprovalMetadata::Approval::level > 1;
}
```


#### Sample 17
```
package UpperLevelApprovals {
    private import ApprovalMetadata::**;
    public import DesignModel::**[@Approval and approved and level > 1];
}
```


#### Sample 18
```
package PackageApprovals {
    private import ApprovalMetadata::*;
    private import SysML::*;
    public import DesignModel::**[@PartDefinition and
        @PartDefinition::ownedPart != null and
        @Approval and
        Approval::approved];
}
```


#### Sample 19
```
action a1 {
                first start;
                then merge m;
                then accept S;
        }
```


#### Sample 20
```
package ActionTest {
        attribute def S;
        action a1 {
                first start;
                then merge m;
                then accept S;
        }
}
```


#### Sample 21
```
package ActionTest {
        action def A{ in x; }
        action a: A { 
                first start;
                action b { in y = x; }
                bind x = b.y;
        }
        attribute def S;
        action a1 {
                first start;
                then merge m;
                then accept S;
        }
}
```


#### Sample 22
```
action a1 {
        first start;		
        then merge m;
        then accept S;
        then accept sig after 10[SI::s]; 
        then accept at new Time::Iso8601DateTime("2022-01-30T01:00:00Z");
        
        then send new S() to b;
        then accept when b.f;
        then decide;
            if true then m;
            else done;
    }
```


#### Sample 23
```
package TestPackage {
        attribute def DimensionOneUnit {
        }
    }
```


#### Sample 24
```
package MeasurementReferences {
        abstract attribute def ScalarMeasurementReference {
        }
    }
```


#### Sample 25
```
part def Transmission {
            port drive: ~DriveIF;
        }
```


#### Sample 26
```
interface driveShaft connect 
            transDrive ::> transmission.drive to axleDrive ::> rearAxle.drive;
```


#### Sample 27
```
package AssignmentTest {
	
	part def Counter {
		attribute count : ScalarValues::Integer := 0;
		
		action incr {
			assign count := count + 1;
		}
		
		action decr {
			assign count := count - 1;
		}
	}
	
	attribute def Incr;
	attribute def Decr;
	
	state def Counting {
		part counter : Counter;
		entry assign counter.count := 0;
		
		then state wait;
		accept Incr
			then increment;
		accept Decr
			then decrement;
		
		state increment {
			do assign counter.count := counter.count + 1;
		}
		then wait;
		
		state decrement {
			do assign counter.count := counter.count - 1;
		}
		then wait;
	}
	
	calc def Increment { 
		in c : Counter;
		return : Counter;
		
		perform c.incr;
		c
	}
	
	action a {
		state counting : Counting;
		assign counting.counter.count := counting.counter.count + 1;
		assign counting.counter.count := Increment(counting.counter).count;
	}
}
```


#### Sample 28
```
part def Counter {
		attribute count : ScalarValues::Integer := 0;
		
		action incr {
			assign count := count + 1;
		}
		
		action decr {
			assign count := count - 1;
		}
	}
```


#### Sample 29
```
state def Counting {
		part counter : Counter;
		entry assign counter.count := 0;
		
		then state wait;
		accept Incr
			then increment;
		accept Decr
			then decrement;
		
		state increment {
			do assign counter.count := counter.count + 1;
		}
		then wait;
		
		state decrement {
			do assign counter.count := counter.count - 1;
		}
		then wait;
	}
```


#### Sample 30
```
calc def Increment { 
		in c : Counter;
		return : Counter;
		
		perform c.incr;
		c
	}
```


#### Sample 31
```
action a {
		state counting : Counting;
		assign counting.counter.count := counting.counter.count + 1;
		assign counting.counter.count := Increment(counting.counter).count;
	}
```


#### Sample 32
```
action def DecisionTest {
        attribute x = 1;

        decide 'test x';
        if x == 1 then A1; 
        if x > 1 then A2;
        else A3; 

        then decide D; 
        if true then A1;
        if false then A2;

        action A1;
        action A2;
        action A3;

        succession S first A1 
                if x == 0 then A2;

        first A3;
                if x > 0 then 'test x';
}
```


#### Sample 33
```
package Test {
        occurrence def APIS_transfer_lifetime {
            interface APIS_transfer_interface : Interfaces::Interface connect (
                tlu ::> X.a, // port reference
                apsph ::> Y.b) {

                flow publish_returnallitems of Publish
                from apspm.pub to mqget.APIS_MQTT.pub;
                flow subscribe_returnallitems of Subscribe
                from apsc.subscr to mqgive.APIS_MQTT.subscr;
                flow call_getItems of CallGiveItems[1]
                from tlu.cll to apsph.cll;
            }
        }
    }
```


#### Sample 34
```
action takePicture {
        action focus: Focus[1];
        flow of Exposure from focus.xrsl to shoot.xsf;
        action shoot: Shoot[1];
    }
```


#### Sample 35
```
#multicausation connection : MultiCauseEffect connect
                ( cause1 ::> causer1, cause2 ::> causer2,
                  effect1 ::> effected1, effect2 ::> effected2 );
```

- `{in p :> ISQ::mass; p > minMass}`

#### Sample 37
```
#derivation connection : Req1_Derivation {
        end r1 ::> req1;
        end r1_1 ::> req1_1;
        end r1_2 ::> req1_2;
    }
```


#### Sample 38
```
part satisfactionContext {
        ref :>> system;
        
        satisfy requirement req1 : Req1 by system;
        
        #derivation connection : Req1_Derivation {
            end r1 ::> req1;
        }
    }
```


#### Sample 39
```
#derivation connection def Req1_Derivation {
        end #original r1 : Req1;
        end #derive r1_1 : Req1_1;
        end #derive r1_2 : Req1_2;
    }
```


#### Sample 40
```
package RequirementDerivationExample {
    private import RequirementDerivation::*;
    
    requirement def Req1;
    
    requirement def Req1_1;
    requirement def Req1_2;
    
    #derivation connection def Req1_Derivation {
        end #original r1 : Req1;
        end #derive r1_1 : Req1_1;
        end #derive r1_2 : Req1_2;
    }
    
    part def System;
    part def Subsystem1;
    part def Subsystem2;
    
    part system : System {
        part sub1 : Subsystem1;
        part sub2 : Subsystem2;
    }
    
    part satisfactionContext {
        ref :>> system;
        
        satisfy requirement req1 : Req1 by system;
        satisfy requirement req1_1 : Req1_1 by system.sub1;
        satisfy requirement req1_2 : Req1_2 by system.sub2;
        
        #derivation connection : Req1_Derivation {
            end r1 ::> req1;
            end r1_1 ::> req1_1;
            end r1_2 ::> req1_1;
        }
        
    }
    
}
```


#### Sample 41
```
action def setX {
        in c : C;
        in newX : Real;
        
        language "alf" 
            /* c.x = newX; */
    }
```


#### Sample 42
```
snapshot :>> start {
        :>> elapseTime = 0 [s];
        :>> pwrCmd.pwrLevel = 0;
    }
```


#### Sample 43
```
variation part def V :> P {
        variant part x : Q {
            attribute b : B;
        }
    }
```


#### Sample 44
```
variation part v : P {
        variant q {
            attribute b : B;
        }
    }
```


#### Sample 45
```
(1..5)->forAll {
        in i : Natural;
        i > 0
    }
```


#### Sample 46
```
(1..5)->forAll {
        in i : Natural;
        private attribute x = i * 2;
        x > 0
    }
```


#### Sample 47
```
(1..numberOfBolts)->forAll {
        in i : Natural;
        private attribute lbcf = lugBolts#(i).coordinateFrame;
        lbcf == null
    }
```


#### Sample 48
```
(1..n)->forAll {
        in i : Natural;
        private attribute trs : TranslationRotationSequence {
            :>> source = wcf;
            :>> target = lbcf;
        }
        trs == null
    }
```


#### Sample 49
```
assert constraint {
        (1..n)->forAll {
            in i : Natural;
            i > 0
        }
    }
```


#### Sample 50
```
part def Wheel :> SpatialItem {
        item :>> shape : Cylinder {
            :>> radius = 22/2*25.4 + 110 [mm]; 
            :>> height = 220 [mm];
        }
        attribute <wcf> wheelCoordinateFrame : CoordinateFrame;
        
        attribute numberOfBolts : Natural = 5;	
        part lugBolts : LugBolt[1..numberOfBolts] :> subSpatialParts;
        
        attribute <lbpr> lugBoltPlacementRadius :>> radius default 60 [mm];
        private attribute lugBoltDistributionAngle :>> planeAngle = 360/numberOfBolts [''];
        private attribute lbda : Real = lugBoltDistributionAngle.num * (pi/180);
        assert constraint {
            (1..numberOfBolts)->forAll {
                in i : Natural;
                private attribute lbcf = lugBolts#(i).coordinateFrame; 
                private attribute trs : TranslationRotationSequence {
                    :>> source = wcf;
                    :>> target = lbcf;
                    :>> elements = new Translation((lbpr*cos((i-1)*lbda), lbpr*sin((i-1)*lbda), -8)[wcf]); 
                }
                lbcf.transformation == trs
            }
        }
    }
```


#### Sample 51
```
part vehicle {
            bind engine.fuelCmdPort=fuelCmdPort;
            
            interface engineInterface:EngineInterface
                connect engine.port1 to trans.port2;
            
            interface fuelInterface:FuelInterface
                connect fuelTank.outPort to engine.inPort;
        }
```


#### Sample 52
```
part vehicle_b : Vehicle {
            bind engine.fuelCmdPort=fuelCmdPort;

            interface engineToTransmissionInterface:EngineToTransmissionInterface
                connect engine.drivePwrPort to transmission.clutchPort;
        
            interface fuelInterface:FuelInterface
                connect fuelTank.fuelOutPort to engine.fuelInPort;

            allocate ActionTree::providePower.generateToAmplify to engineToTransmissionInterface;
        }
```


#### Sample 53
```
package Test {
    #refinement dependency engine4Cyl to VehicleConfiguration_b::PartsTree::vehicle_b::engine;
}
```


#### Sample 54
```
@Rationale about engineTradeOffAnalysis::vehicle_b_engine4cyl{
        explanation = VehicleAnalysis::VehicleTradeOffAnalysis::engineTradeOffAnalysis;          
        text = "the engine4cyl was evaluated";
    }
```


#### Sample 55
```
analysis engineTradeOffAnalysis:TradeStudy{
        subject vehicleAlternatives[2]:>vehicle_b;   
        
        part vehicle_b_engine4cyl:>vehicleAlternatives{   
            part engine redefines engine{
                part cylinders :>> cylinders [4];
                attribute mass redefines mass=180 [kg];
            }
        }
    }
```


#### Sample 56
```
part vehicle {
                    interface engineToTransmissionInterface:EngineToTransmissionInterface
                        connect engine.drivePwrPort to transmission.clutchPort;
                
                    interface fuelInterface:FuelInterface
                        connect fuelTank.fuelOutPort to engine.fuelInPort;
                }
```


#### Sample 57
```
part vehicle {
                        part seatBelt[2] {@Safety{isMandatory = true;}}
                        part frontSeat[2];
                        part driverAirBag {@Safety{isMandatory = false;}}
                    }
                    
                    //connections
                    bind engine.fuelCmdPort=fuelCmdPort;

                    interface engineToTransmissionInterface:EngineToTransmissionInterface
                        connect engine.drivePwrPort to transmission.clutchPort;
                
                    interface fuelInterface:FuelInterface
                        connect fuelTank.fuelOutPort to engine.fuelInPort;

                    allocate ActionTree::providePower.generateToAmplify to engineToTransmissionInterface;
                    
                    bind engine.ignitionCmdPort=ignitionCmdPort;
                    connect starterMotor.gearPort to engine.flyWheelPort;
                    connect vehicleSoftware.vehicleController.controlPort to engine.engineControlPort;
                    bind vehicle_b.setSpeedPort = vehicleSoftware.vehicleController.cruiseController.setSpeedPort;
                    connect speedSensor.speedSensorPort to vehicleSoftware.vehicleController.cruiseController.speedSensorPort;
                    bind vehicleSoftware.vehicleController.cruiseController.cruiseControlPort = vehicleSoftware.vehicleController.controlPort;
                    connect transmission.shaftPort_a to driveshaft.shaftPort_b; 
                    connect driveshaft.shaftPort_c to rearAxleAssembly.shaftPort_d;
                    bind rearAxleAssembly.rearWheel1.wheelToRoadPort=vehicleToRoadPort.wheelToRoadPort1;
                    bind rearAxleAssembly.rearWheel2.wheelToRoadPort=vehicleToRoadPort.wheelToRoadPort2;
    }
```


#### Sample 58
```
allocation def Logical_to_Physical :> A {
        end logical : Logical;
        end physical : Physical;
    }
```


#### Sample 59
```
package Engine4Cyl_Variant{
            public import ModelingMetadata::*;
            part engine:Engine{
                part cylinders:Cylinder[4..8] ordered;
            }
            part engine4Cyl:>engine{
                part redefines cylinders [4];
                part cylinder1 subsets cylinders[1];
                part cylinder2 subsets cylinders[1];
                part cylinder3 subsets cylinders[1];
                part cylinder4 subsets cylinders[1];
            }
            #refinement dependency engine4Cyl to VehicleConfiguration_b::PartsTree::vehicle_b::engine;
        }
```


#### Sample 60
```
package VehicleTradeOffAnalysis{
            @Rationale about engineTradeOffAnalysis::vehicle_b_engine4cyl{
                explanation = VehicleAnalysis::VehicleTradeOffAnalysis::engineTradeOffAnalysis;          
                text = "the engine4cyl was evaluated to have a higher objective function compared to the engine6cyl based on the trade-off analyiss"; 
            }
        }
```


#### Sample 61
```
part vehicle_b_engine4cyl:>vehicleAlternatives{   
                    part engine redefines engine{
                        part cylinders :>> cylinders [4];
                        attribute mass redefines mass=180 [kg];
                        attribute peakHorsePower redefines peakHorsePower = 180 [W];
                        attribute fuelEfficiency redefines fuelEfficiency=.6;
                        attribute cost redefines cost = 1000;                     
                    }
                }
```


#### Sample 62
```
part def A {
		part <'1'> b: B;
	}
```


#### Sample 63
```
package PartTest {
	
	part f: A;

	public part def A {
		part <'1'> b: B;
		protected port c: C;
		constant attribute x[0..2];
		derived constant ref attribute y :> x;
		ref z : ScalarValues::Integer;
	}
}
```


#### Sample 64
```
verification massTests:MassTest {
                subject vehicle_uut :> vehicle_b;
                actor vehicleVerificationSubSystem_1 = verificationContext.massVerificationSystem;
                objective {
                    verify vehicleSpecification.vehicleMassRequirement{
                        redefines massActual=weighVehicle.massMeasured;
                    }
                }     
               @ VerificationMethod{
                    kind = (VerificationMethodKind::test, VerificationMethodKind::analyze);
                }
                action weighVehicle {
                    out massMeasured:>ISQ::mass;
                }
                then action evaluatePassFail {
                    in massMeasured:>ISQ::mass;
                    out verdict = PassIf(vehicleSpecification.vehicleMassRequirement(vehicle_uut));
                }
                flow from weighVehicle.massMeasured to evaluatePassFail.massMeasured;
                return :>> verdict = evaluatePassFail.verdict;
            }
```


#### Sample 65
```
use case transportPassenger:TransportPassenger{
                first start;
                then action a{
                    action driverGetInVehicle;
                }
                then action trigger accept ignitionCmd:IgnitionCmd;
                then action b{
                    action driveVehicleToDestination;
                }
                then action c{
                    action driverGetOutOfVehicle;
                }
                then done;
            }
```


#### Sample 66
```
package ScalarValues {
    attribute def Real;
}
package TestWithStdlib {

part def Calculator {
    attribute result : ScalarValues::Real;
}

part cal : Calculator;
}
```


#### Sample 67
```
package Test {
    item def IgnitionCmd;
    
    part part0 {
        perform action startVehicle {
            action turnVehicleOn send ignitionCmd via p1 {
                in ignitionCmd : IgnitionCmd;
            }
        }
    }
}
```

- `abstract`
- `action`
- `alias`
- `allocation`
- `attribute`
- `calc`
- `comment`
- `connection`
- `constraint`
- `decide`
- `dependency`
- `entry`
- `enum`
- `exit`
- `flow`
- `fork`
- `import`
- `interface`
- `item`
- `join`
- `library`
- `merge`
- `metadata`
- `occurrence`
- `package`
- `part`
- `port`
- `redefines`
- `rendering`
- `requirement`
- `specializes`
- `standard`
- `state`
- `subsets`
- `succession`
- `transition`
- `view`
- `viewpoint`
- `// this is a comment`
- `/* block comment */`
- `fork;`
- `fork myFork;`
- `merge;`
- `merge myMerge;`
- `join;`
- `join myJoin;`
- `decide;`
- `decide myDecision;`
- `entry myEntryAction;`
- `exit myExitAction;`
- `do myDoAction;`
- `accept myAcceptFeature;`
- `succession mySuccession first source then target;`
- `expose MyNamespace::*;`
- `require myConstraint;`
- `~MyPort`
- `terminate myOccurrence;`
- `port def ~MyConjugatedPort;`
- `port myPort : ~ConjugatedPortType;`
- `package MyPackage;`
- `package MyPackage { }`
- `library package MyLibrary;`
- `standard library package MyLibrary;`
- `package Pkg1; package Pkg2;`
- `package MyPackage { part myPart; }`
- `dependency from A to B;`
- `dependency A to B;`
- `dependency 'Service Layer' to 'Data Layer' { }`
- `dependency from A, B, C to D;`
- `dependency from A to B, C, D;`
- `dependency myDep from A to B;`
- `dependency from A to B { comment MyComment; }`
- `comment MyComment about MyElement;`
- `/* comment text */`
- `about Foo;`
- `doc MyDoc;`
- `/* docs */`
- `/* comment */`
- `#MyMetadata;`
- `comment MyComment;`
- `{ comment MyComment; }`
- `metadata def MyMetadata;`
- `abstract metadata def MyMetadata;`
- `#MyMetadata`
- `metadata MyMetadata;`
- `@MyMetadata;`
- `metadata MyMetadata about A, B;`
- `metadata myMeta : MyMetadata;`
- `metadata MyMetadata { }`
- `ref :>> MyReference;`
- `metadata InterfaceCompatibilityIssue : Issue about engineToTransmissionInterface { text = "issue"; }`
- `package;`
- `ref state myState;`
- `abstract ref state exhibitedStates: StateAction[0..*] { }`
- `part myPart;`
- `public part myPart;`
- `alias MyAlias for MyElement;`
- `private alias MyAlias for MyElement;`
- `import MyElement;`
- `public import MyElement;`
- `import all MyElement;`
- `import MyElement::*;`
- `import MyElement::*::**;`
- `import MyElement [condition];`
- `import MyElement [filter1][filter2];`
- `import MyElement { }`
- `attribute def MyAttribute;`
- `enum def MyEnum;`
- `occurrence def MyOccurrence;`
- `individual def MyIndividual;`
- `item def MyItem;`
- `part def MyPart;`
- `connection def MyConnection;`
- `interface def MyInterface;`
- `allocation def MyAllocation;`
- `port def MyPort;`
- `action def MyAction;`
- `calc def MyCalc;`
- `state def MyState;`
- `constraint def MyConstraint;`
- `requirement def MyRequirement;`
- `concern def MyConcern;`
- `case def MyCase;`
- `analysis case def MyAnalysisCase;`
- `verification case def MyVerificationCase;`
- `use case def MyUseCase;`
- `view def MyView;`
- `viewpoint def MyViewpoint;`
- `rendering def MyRendering;`
- `attribute myAttr;`
- `BaseClass`
- `'Quoted Classifier'`
- `:> Base`
- `:> Base1, Base2, Base3`
- `:> BaseFeature`
- `::> ReferencedFeature`
- `:>> RedefinedFeature`
- `: Type1 [1] :> Base`
- `end item cart: ShoppingCart[1] crosses selectedProduct.inCart;`
- `myFeature`
- `'Quoted Feature'`
- `BaseFeature`
- `RefFeature`
- `RedefinedFeature`
- `base.feature`
- `MyDef { }`
- `MyDef :> Base;`
- `MyDef :> Base { }`
- `MyDef :> Base`
- `attribute def MyAttr;`
- `interaction`
- `abstractconstant`
- `abstractderived`
- `item myItem;`
- `action myAction;`
- `port myPort;`
- `connection myConn;`
- `calc myCalc;`
- `state myState;`
- `constraint myConstraint;`
- `#meta def ExtendedDef;`
- `abstract #meta def ExtendedDef { }`
- `#meta #meta2 def ExtendedDef :> Base;`
- `attribute def Speed;`
- `attribute def Speed :> Real;`
- `abstract attribute def Speed { }`
- `attribute speed;`
- `attribute speed : Real;`
- `ref attribute speed;`
- `enum def Color;`
- `enum def Color { }`
- `#meta enum def Status { }`
- `enum green;`
- `enum status;`
- `enum status : Status;`
- `ref enum myEnum;`
- `occurrence def Occurrence1;`
- `occurrence def Occurrence1 { }`
- `abstract occurrence def Occurrence1;`
- `individual occurrence def UniqueOccurrence;`
- `individual def Thing;`
- `individual def Thing { }`
- `abstract individual def UniqueThing;`
- `occurrence occ1;`
- `occurrence occ1 { }`
- `ref individual occurrence uniqueOcc;`
- `snapshot occurrence snap1;`
- `out individual thing : Type;`
- `item def MyItem { }`
- `abstract item def MyItem;`
- `individual item def UniqueItem;`
- `item myItem { }`
- `ref individual item uniqueItem;`
- `snapshot item snap1;`
- `part def MyPart { }`
- `abstract part def MyPart;`
- `individual part def UniquePart;`
- `part myPart { }`
- `ref individual part uniquePart;`
- `snapshot part snap1;`
- `port myPort { }`
- `ref individual port uniquePort;`
- `snapshot port snap1;`
- `connection def MyConnection { }`
- `abstract connection def MyConnection;`
- `connection myConn { }`
- `connection myConn connect source to target;`
- `interface def Vehicle { port driver; }`
- `abstract interface def DataInterface { ref data : DataType; }`
- `{ port driver; }`
- `ref data : DataType;`
- `port sensor;`
- `interface connect left to right;`
- `interface connect left to right{}`
- `constant interface connect left to right;`
- `constant interface interfaceA connect left to right;`
- `interface leftFrontMount: Mounting connect frontAxle.leftMountingPoint to leftFrontWheel.hub;`
- `(portA, portB)`
- `(portA, portB, portC)`
- `portA`
- `flow def DataFlow;`
- `flow def FluidFlow { }`
- `abstract flow def AbstractFlow;`
- `payload - bare type name (OwnedFeatureTyping)`
- `: DataType [1]`
- `myFlow`
- `flowRef`
- `BaseFlow`
- `action def Move;`
- `action def Calculate { }`
- `abstract action def AbstractAction;`
- `perform myAction;`
- `actionRef`
- `action a { first start; then accept S; }`
- `action a { first start; then merge m; then accept S; }`

#### Sample 303
```
action a1 {
        first start;		
        then merge m;
        then accept S;
        then accept sig after 10[SI::s]; 
        then accept at new Time::Iso8601DateTime(
```


#### Sample 304
```
);
        
        then send new S() to b;
        then accept when b.f;
        then decide;
            if true then m;
            else done;
    }
```

- `msg : MessageType = defaultValue`
- `feature`
- `binding.feature`
- `featureRef`
- `for x in items {}`
- `state def MyState {}`
- `state def MyState parallel {}`
- `action entryAction;`
- `action doAction: Action;`
- `action exercise : Exercise { }`
- `entry action entryAction;`
- `entry action warmup : WarmUp;`
- `entry action entryAction :>> 'entry';`
- `entry;`
- `entry setupSensor;`
- `do action doAction;`
- `do action exercise : Exercise;`
- `do action doAction: Action :>> 'do';`
- `do action exercise : Exercise { }`
- `exit action exitAction;`
- `exit action cooldown : Cooldown;`
- `exit action exitAction: Action :>> 'exit';`
- `exit;`
- `exit cleanup;`
- `state;`
- `state {}`
- `state parallel {}`
- `exhibit state;`
- `exhibit state MyState;`
- `transition first S1 then S2;`
- `transition T first S1 then S2;`

#### Sample 336
```
transition
    first S1
    then S2;
```


#### Sample 337
```
transition T
    first S2.S3
    accept s : Sig via p
    if true
    do send s to p
    then S1;
```

- `allocation myAlloc;`
- `allocation allocation1 : Logical_to_Physical allocate l to p;`

#### Sample 340
```
allocation allocation2 : Logical_to_Physical allocate (
    logical ::> l,
    physical ::> p
);
```

- `calc def MyCalc {}`
- `calc def Increment { in c : Counter; return : Counter; perform c.incr; c }`
- `{ in c : Counter; return : Counter; perform c.incr; c }`
- `calc;`
- `calc {}`
- `constraint def MyConstraint {}`
- `constraint;`
- `constraint {}`
- `assert constraint;`
- `requirement def SafetyRequirement;`
- `requirement def SafetyRequirement {}`
- `requirement def SafetyRequirement { /* requirement doc */ }`
- `subject subj : MyType default myValue;`
- `myConstraint {}`
- `assume myConstraint {}`
- `require constraint {}`
- `requirement myReq {}`
- `concern def PerformanceConcern;`
- `concern def PerformanceConcern {}`
- `concern def BrakingConcern { require constraint { /**/ } }`
- `concern def SafetyConcern { subject vehicle; stakeholder driver; }`
- `case def TestCase;`
- `case def TestCase {}`
- `case def TestCase { subject testSubject; }`
- `obj : RequirementCheck[1] { subject subj default Case::result; }`
- `objective obj : RequirementCheck[1] { subject subj default Case::result; }`
- `analysis case def AnalysisTest;`
- `analysis case def AnalysisTest {}`
- `analysis case def AnalysisTest { subject testSubject; }`
- `verification case def VerifyTest;`
- `verification case def VerifyTest {}`
- `verification case def VerifyTest { objective myObj {} }`
- `use case def TestUseCase;`
- `use case def TestUseCase {}`
- `view def TestView;`
- `view def TestView {}`
- `myRendering;`
- `rendering myRender {}`
- `render myRendering;`
- `view myView;`
- `view myView {}`
- `viewpoint def TestViewpoint;`
- `viewpoint def TestViewpoint {}`
- `viewpoint def TestViewpoint { stakeholder user; }`
- `viewpoint myViewpoint;`
- `viewpoint myViewpoint {}`
- `rendering def TestRendering;`
- `rendering def TestRendering {}`
- `rendering myRendering;`
- `Package should have 1 member`
- `MyPort`
- `port drive: ~DriveIF;`
- `port input: ~InputPort;`
- `port p: ~Pkg::PortDef;`
- `port drive: DriveIF;`
- `port p: MyPort;`
- `transDrive ::> transmission.drive`
- `axleDrive ::> rearAxle.drive`
- `p ::> port1`
- `interface fuelLine : FuelingInterface connect fuelTank.fuelingPort to engine.fuelingPort;`
- `interface fuelTank.fuelingPort to engine.fuelingPort;`
- `interface myInterface connect portA to portB;`
- `interface conn connect a.p to b.p { }`
- `interface system.input to system.output;`
- `interface def FuelingInterface { end fuelOutPort : FuelingPort; end fuelInPort : ~FuelingPort; }`
- `interface def DataIF { end sender : DataPort; end receiver : ~DataPort; }`
- `myPackage`
- `myPackage::**`
- `myPackage::*`
- `flow a to b;`
- `flow a.b to c;`
- `flow a to b.c;`
- `flow a.b to c.d;`
- `flow b.f.a to c.aa;`
- `someAction;`
- `succession flow x.p to a.b;`
- `succession flow a to b;`
- `succession flow onOffCmdFlow from sendOnOffCmd.onOffCmd to produceDirectedLight.onOffCmd;`
- `succession S first A1 then A2;`
- `succession S first A1 if x == 0 then A2;`
- `myFlow : Exposure from x to y`
- `call_getItems of CallGiveItems[1] from tlu.cll to apsph.cll`
- `flow publish of Publish from a.b to c.d;`

#### Sample 424
```
flow publish of Publish
from a.b to c.d;
```


#### Sample 425
```
flow publish of Publish\r
from a.b to c.d;
```

- `cause1 ::> causer1`
- `effect1 ::> effected1`
- `in p : ISQ::mass`
- `in p :> ISQ::mass`
- `p :> ISQ::mass`
- `satisfy requirement req1 : Req1 by system;`
- `satisfy requirement req1_1 : Req1_1 by system.sub1;`

#### Sample 433
```
action def setX {
        in c : C;
        in newX : Real;
        
        language
```

- `:>> localClock.currentTime`
- `attribute :>> localClock.currentTime;`
- `:>> localClock.currentTime;`
- `attribute :>> localClock.currentTime = startTime + elapseTime;`
- `in i : Natural`
- `transition initial then off;`
- `entry action initial;`
- `ActionTree::providePower.generateToAmplify`
- `ActionTree::providePower`
- `allocate ActionTree::providePower.generateToAmplify to engineToTransmissionInterface;`
- `allocate (logical ::> l, physical ::> p);`
- `ActionTree::providePower.generateToAmplify to engineInterface`
- `allocate ActionTree::providePower.generateToAmplify to engineInterface;`

#### Sample 447
```
interface fuelInterface:FuelInterface
                        connect fuelTank.fuelOutPort to engine.fuelInPort;
```

- `#refinement dependency engine4Cyl to VehicleConfiguration_b::PartsTree::vehicle_b::engine;`
- `fuelInterface:FuelInterface connect fuelTank.fuelOutPort to engine.fuelInPort`

#### Sample 450
```
@Rationale about engineTradeOffAnalysis::vehicle_b_engine4cyl{
        explanation = VehicleAnalysis::VehicleTradeOffAnalysis::engineTradeOffAnalysis;          
        text =
```

- `part cylinders :>> cylinders [4];`
- `attribute mass redefines mass=180 [kg];`

#### Sample 453
```
package VehicleTradeOffAnalysis{
            @Rationale about engineTradeOffAnalysis::vehicle_b_engine4cyl{
                explanation = VehicleAnalysis::VehicleTradeOffAnalysis::engineTradeOffAnalysis;          
                text =
```

- `PassIf(vehicleSpecification.vehicleMassRequirement(vehicle_uut))`
- `out verdict = PassIf(vehicleSpecification.vehicleMassRequirement(vehicle_uut));`
- `= PassIf(vehicleSpecification.vehicleMassRequirement(vehicle_uut))`
- `out verdict = 5;`
- `out verdict = foo(x);`
- `out verdict = foo.bar(x);`
- `use case transportPassenger:TransportPassenger;`
- `package P { use case transportPassenger:TransportPassenger; }`
- `then action trigger accept ignitionCmd:IgnitionCmd;`

#### Sample 463
```
use case transportPassenger:TransportPassenger{
                first start;
                then action trigger accept ignitionCmd:IgnitionCmd;
            }
```

- `file.namespace: {:?}`
- `element[{}] = Package({:?})`
- `element[{i}] = Comment`
- `element[{i}] = Import`
- `element[{i}] = Alias`
- `element[{i}] = Dependency`
- `Calculator`
- `satisfy Requirements::REQ1 by RoboticVacuumCleaner::battery;`
- `satisfy req by system.component.feature;`
- `requirement def <'REQ-1'> SafetyReq { }`
- `supplierPort => Source::output`
- `interface connect supplierPort => Source::FEnergy to consumerPort => Consumer::FEnergy;`
- `(in a, out b, inout c)`
- `(current:>SI::A, voltage:>ISQ::voltage)`
- `(in 'input data', out 'output data')`
- `calc def Torque (current:>SI::A, voltage:>ISQ::voltage):> ISQ::torque { }`
- `calc def Compute (in x, in y, out result) { }`
- `calc def Simple :> BaseCalc;`
- `calc def Mixed (in x) :> BaseCalc { }`
- `action def Process (in data, out result) { }`
- `action def Drive :> Action;`
- `action def Combined (in x) :> BaseAction { }`
- `action convertEnergy:ConvertEnergy (in current, in voltage, out energy);`
- `action doSomething;`
- `action compute (in x, out y);`
- `expose MyPackage::*::**;`
- `=== Parsed File Structure ===`
- `Package: {}`

### Test Functions (138 total)
- test_parse_simple_identifier
- test_parse_line_comment
- test_parse_block_comment
- test_parse_multiline_block_comment
- test_parse_empty_file
- test_parse_file_with_whitespace
- test_parse_entry_action
- test_parse_exit_action
- test_parse_do_action
- test_parse_accept_feature
- test_parse_if_feature
- test_parse_subject_membership
- test_parse_actor_membership
- test_parse_stakeholder_membership
- test_parse_objective_membership
- test_parse_expose
- test_parse_membership_expose
- test_parse_namespace_expose
- test_parse_requirement_constraint_membership
- test_parse_framed_concern_membership
- test_parse_requirement_verification_membership
- test_parse_conjugated_port_type_reference
- test_parse_variant_membership
- test_parse_terminate_action
- test_parse_conjugated_port_definition
- test_parse_port_usage_with_conjugated_type
- test_parse_comment
- test_parse_documentation
- test_parse_textual_representation
- test_parse_metadata_usage
- test_parse_annotating_element
- test_parse_relationship_body_with_annotation
- test_parse_dependency_with_comment_in_body
- test_parse_cases_sysml_fragment
- test_parse_simplified_case_with_objective
- test_parse_requirement_body_with_subject
- test_parse_objective_member_in_case_body
- test_parse_case_body_with_objective
- test_parse_objective_as_case_body_item
- test_parse_minimal_case_body
- test_parse_ref_state_usage
- test_parse_abstract_ref_state_usage
- test_parse_ref_state_as_definition_body_item
- test_parse_state_with_doc_comment
- test_parse_constraint_with_doc_comment
- test_parse_package_with_filter_statement
- test_parse_package_with_filtered_import
- test_parse_full_filter_spec_example
- test_parse_action_a1_full
- test_case_body_item_does_not_match_expression
- test_parse_attribute_def_from_stdlib
- test_parse_abstract_attribute_def
- test_part_def_with_conjugated_port
- test_interface_usage_with_references_operator
- test_parse_assignment_test_package_full
- test_parse_part_def_counter_with_actions
- test_parse_state_def_with_entry_and_do_assignments
- test_parse_calc_def_with_perform
- test_parse_action_with_state_and_calc_invocation
- test_parse_decision_test_action_def
- test_parse_interface_usage_with_flows
- test_parse_picture_taking_action
- test_parse_nary_connector_with_metadata
- test_parse_select_expression_body
- test_parse_derivation_connection_with_end_elements
- test_parse_part_with_derivation_connection
- test_parse_satisfy_requirement
- test_parse_satisfy_requirement_with_dot
- test_parse_derivation_connection_def
- test_parse_full_requirement_derivation_example
- test_parse_action_with_textual_rep
- test_parse_feature_chain_in_redefinition
- test_parse_feature_specialization_with_redefinition
- test_parse_attribute_with_redefinition_no_value
- test_parse_usage_suffix_with_redefinition
- test_parse_anonymous_attribute_with_redefinition
- test_parse_anonymous_redefinition_in_snapshot
- test_parse_include_use_case_with_typing
- test_parse_include_use_case_with_body
- test_parse_include_shorthand
- test_parse_include_with_feature_chain
- test_parse_variation_part_def
- test_parse_variation_part_usage
- test_parse_forall_with_parameter
- test_parse_forall_with_private_attribute
- test_parse_forall_with_hash_access
- test_parse_forall_with_attribute_body
- test_parse_new_with_subscript
- test_parse_parameter_binding_with_in
- test_parse_forall_in_constraint
- test_parse_wheel_part_def_with_forall
- test_parse_transition_from_initial
- test_parse_entry_action_initial
- test_parse_bind_and_interface_sequence
- test_parse_bind_interface_allocate_sequence
- test_parse_allocate_feature_chain
- test_parse_short_feature_reference
- test_parse_connector_end_for_allocate
- test_parse_allocate_end_member
- test_parse_binary_allocate_simple
- test_parse_allocate_from_line_705
- test_parse_allocate_end
- test_parse_allocate_nested_features
- test_parse_nary_allocate_with_subsetting
- test_parse_binary_allocate_part
- test_parse_allocate_with_qualified_feature_chain
- test_parse_interface_implicit_body
- test_parse_dependency_with_metadata
- test_parse_dependency_in_package
- test_parse_interface_decl_with_connect_v2
- test_parse_metadata_with_about_qualified
- test_parse_part_typed_by_redefinition_with_multiplicity
- test_parse_attribute_redefines_with_unit
- test_parse_analysis_from_line_1165
- test_parse_part_with_two_interfaces
- test_parse_full_context_with_interfaces
- test_parse_allocation_def_with_end_features
- test_parse_refinement_dependency
- test_parse_metadata_about_qualified_name
- test_parse_redefines_with_inline_value
- test_parse_part_with_quoted_short_name
- test_parse_part_test_file
- test_parse_verification_with_actions
- test_parse_nested_function_call
- test_parse_out_param_nested_function_call
- test_parse_feature_value_nested_call
- test_parse_simple_directed_parameter
- test_parse_directed_parameter_func_call
- test_parse_directed_parameter_dotted_func_call
- test_parse_expression_dotted_func_call
- test_parse_use_case_usage
- test_parse_use_case_in_package
- test_parse_action_trigger_accept
- test_parse_use_case_with_trigger_accept
- test_parse_then_done
- test_parse_use_case_full_flow
- test_parse_package_with_nested_elements_issue
- test_debug_send_node_ast